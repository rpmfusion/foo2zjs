diff -uNr foo2zjs-patch1/jbig_ar.c foo2zjs/jbig_ar.c
--- foo2zjs-patch1/jbig_ar.c	2008-09-05 17:05:54.000000000 +0200
+++ foo2zjs/jbig_ar.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,426 +0,0 @@
-/*
- *  Arithmetic encoder and decoder of the portable JBIG
- *  compression library
- *
- *  Markus Kuhn -- http://www.cl.cam.ac.uk/~mgk25/jbigkit/
- *
- *  This module implements a portable standard C arithmetic encoder
- *  and decoder used by the JBIG lossless bi-level image compression
- *  algorithm as specified in International Standard ISO 11544:1993
- *  and ITU-T Recommendation T.82.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- * 
- *  If you want to use this program under different license conditions,
- *  then contact the author for an arrangement.
- *
- *  It is possible that certain products which can be built using this
- *  software module might form inventions protected by patent rights in
- *  some countries (e.g., by patents about arithmetic coding algorithms
- *  owned by IBM and AT&T in the USA). Provision of this software by the
- *  author does NOT include any licences for any patents. In those
- *  countries where a patent licence is required for certain applications
- *  of this software module, you will have to obtain such a licence
- *  yourself.
- */
-
-#include <assert.h>
-#include "jbig_ar.h"
-
-/*
- *  Probability estimation tables for the arithmetic encoder/decoder
- *  given by ITU T.82 Table 24.
- */
-
-static short lsztab[113] = {
-  0x5a1d, 0x2586, 0x1114, 0x080b, 0x03d8, 0x01da, 0x00e5, 0x006f,
-  0x0036, 0x001a, 0x000d, 0x0006, 0x0003, 0x0001, 0x5a7f, 0x3f25,
-  0x2cf2, 0x207c, 0x17b9, 0x1182, 0x0cef, 0x09a1, 0x072f, 0x055c,
-  0x0406, 0x0303, 0x0240, 0x01b1, 0x0144, 0x00f5, 0x00b7, 0x008a,
-  0x0068, 0x004e, 0x003b, 0x002c, 0x5ae1, 0x484c, 0x3a0d, 0x2ef1,
-  0x261f, 0x1f33, 0x19a8, 0x1518, 0x1177, 0x0e74, 0x0bfb, 0x09f8,
-  0x0861, 0x0706, 0x05cd, 0x04de, 0x040f, 0x0363, 0x02d4, 0x025c,
-  0x01f8, 0x01a4, 0x0160, 0x0125, 0x00f6, 0x00cb, 0x00ab, 0x008f,
-  0x5b12, 0x4d04, 0x412c, 0x37d8, 0x2fe8, 0x293c, 0x2379, 0x1edf,
-  0x1aa9, 0x174e, 0x1424, 0x119c, 0x0f6b, 0x0d51, 0x0bb6, 0x0a40,
-  0x5832, 0x4d1c, 0x438e, 0x3bdd, 0x34ee, 0x2eae, 0x299a, 0x2516,
-  0x5570, 0x4ca9, 0x44d9, 0x3e22, 0x3824, 0x32b4, 0x2e17, 0x56a8,
-  0x4f46, 0x47e5, 0x41cf, 0x3c3d, 0x375e, 0x5231, 0x4c0f, 0x4639,
-  0x415e, 0x5627, 0x50e7, 0x4b85, 0x5597, 0x504f, 0x5a10, 0x5522,
-  0x59eb
-};
-
-static unsigned char nmpstab[113] = {
-    1,   2,   3,   4,   5,   6,   7,   8,
-    9,  10,  11,  12,  13,  13,  15,  16,
-   17,  18,  19,  20,  21,  22,  23,  24,
-   25,  26,  27,  28,  29,  30,  31,  32,
-   33,  34,  35,   9,  37,  38,  39,  40,
-   41,  42,  43,  44,  45,  46,  47,  48,
-   49,  50,  51,  52,  53,  54,  55,  56,
-   57,  58,  59,  60,  61,  62,  63,  32,
-   65,  66,  67,  68,  69,  70,  71,  72,
-   73,  74,  75,  76,  77,  78,  79,  48,
-   81,  82,  83,  84,  85,  86,  87,  71,
-   89,  90,  91,  92,  93,  94,  86,  96,
-   97,  98,  99, 100,  93, 102, 103, 104,
-   99, 106, 107, 103, 109, 107, 111, 109,
-  111
-};
-
-/*
- * least significant 7 bits (mask 0x7f) of nlpstab[] contain NLPS value,
- * most significant bit (mask 0x80) contains SWTCH bit
- */
-static unsigned char nlpstab[113] = {
-  129,  14,  16,  18,  20,  23,  25,  28,
-   30,  33,  35,   9,  10,  12, 143,  36,
-   38,  39,  40,  42,  43,  45,  46,  48,
-   49,  51,  52,  54,  56,  57,  59,  60,
-   62,  63,  32,  33, 165,  64,  65,  67,
-   68,  69,  70,  72,  73,  74,  75,  77,
-   78,  79,  48,  50,  50,  51,  52,  53,
-   54,  55,  56,  57,  58,  59,  61,  61,
-  193,  80,  81,  82,  83,  84,  86,  87,
-   87,  72,  72,  74,  74,  75,  77,  77,
-  208,  88,  89,  90,  91,  92,  93,  86,
-  216,  95,  96,  97,  99,  99,  93, 223,
-  101, 102, 103, 104,  99, 105, 106, 107,
-  103, 233, 108, 109, 110, 111, 238, 112,
-  240
-};
-
-/*
- * The next functions implement the arithmedic encoder and decoder
- * required for JBIG. The same algorithm is also used in the arithmetic
- * variant of JPEG.
- */
-
-/* marker codes */
-#define MARKER_STUFF    0x00
-#define MARKER_ESC      0xff
-
-void arith_encode_init(struct jbg_arenc_state *s, int reuse_st)
-{
-  int i;
-  
-  if (!reuse_st)
-    for (i = 0; i < 4096; s->st[i++] = 0);
-  s->c = 0;
-  s->a = 0x10000L;
-  s->sc = 0;
-  s->ct = 11;
-  s->buffer = -1;    /* empty */
-  
-  return;
-}
-
-
-void arith_encode_flush(struct jbg_arenc_state *s)
-{
-  unsigned long temp;
-
-  /* find the s->c in the coding interval with the largest
-   * number of trailing zero bits */
-  if ((temp = (s->a - 1 + s->c) & 0xffff0000L) < s->c)
-    s->c = temp + 0x8000;
-  else
-    s->c = temp;
-  /* send remaining bytes to output */
-  s->c <<= s->ct;
-  if (s->c & 0xf8000000L) {
-    /* one final overflow has to be handled */
-    if (s->buffer >= 0) {
-      s->byte_out(s->buffer + 1, s->file);
-      if (s->buffer + 1 == MARKER_ESC)
-	s->byte_out(MARKER_STUFF, s->file);
-    }
-    /* output 0x00 bytes only when more non-0x00 will follow */
-    if (s->c & 0x7fff800L)
-      for (; s->sc; --s->sc)
-	s->byte_out(0x00, s->file);
-  } else {
-    if (s->buffer >= 0)
-      s->byte_out(s->buffer, s->file); 
-    /* T.82 figure 30 says buffer+1 for the above line! Typo? */
-    for (; s->sc; --s->sc) {
-      s->byte_out(0xff, s->file);
-      s->byte_out(MARKER_STUFF, s->file);
-    }
-  }
-  /* output final bytes only if they are not 0x00 */
-  if (s->c & 0x7fff800L) {
-    s->byte_out((s->c >> 19) & 0xff, s->file);
-    if (((s->c >> 19) & 0xff) == MARKER_ESC)
-      s->byte_out(MARKER_STUFF, s->file);
-    if (s->c & 0x7f800L) {
-      s->byte_out((s->c >> 11) & 0xff, s->file);
-      if (((s->c >> 11) & 0xff) == MARKER_ESC)
-	s->byte_out(MARKER_STUFF, s->file);
-    }
-  }
-
-  return;
-}
-
-
-void arith_encode(struct jbg_arenc_state *s, int cx, int pix) 
-{
-  register unsigned lsz, ss;
-  register unsigned char *st;
-  long temp;
-
-  assert(cx >= 0 && cx < 4096);
-  st = s->st + cx;
-  ss = *st & 0x7f;
-  assert(ss < 113);
-  lsz = lsztab[ss];
-
-#if 0
-  fprintf(stderr, "pix = %d, cx = %d, mps = %d, st = %3d, lsz = 0x%04x, "
-	  "a = 0x%05lx, c = 0x%08lx, ct = %2d, buf = 0x%02x\n",
-	  pix, cx, !!(s->st[cx] & 0x80), ss, lsz, s->a, s->c, s->ct,
-	  s->buffer);
-#endif
-
-  if (((pix << 7) ^ s->st[cx]) & 0x80) {
-    /* encode the less probable symbol */
-    if ((s->a -= lsz) >= lsz) {
-      /* If the interval size (lsz) for the less probable symbol (LPS)
-       * is larger than the interval size for the MPS, then exchange
-       * the two symbols for coding efficiency, otherwise code the LPS
-       * as usual: */
-      s->c += s->a;
-      s->a = lsz;
-    }
-    /* Check whether MPS/LPS exchange is necessary
-     * and chose next probability estimator status */
-    *st &= 0x80;
-    *st ^= nlpstab[ss];
-  } else {
-    /* encode the more probable symbol */
-    if ((s->a -= lsz) & 0xffff8000L)
-      return;   /* A >= 0x8000 -> ready, no renormalization required */
-    if (s->a < lsz) {
-      /* If the interval size (lsz) for the less probable symbol (LPS)
-       * is larger than the interval size for the MPS, then exchange
-       * the two symbols for coding efficiency: */
-      s->c += s->a;
-      s->a = lsz;
-    }
-    /* chose next probability estimator status */
-    *st &= 0x80;
-    *st |= nmpstab[ss];
-  }
-
-  /* renormalization of coding interval */
-  do {
-    s->a <<= 1;
-    s->c <<= 1;
-    --s->ct;
-    if (s->ct == 0) {
-      /* another byte is ready for output */
-      temp = s->c >> 19;
-      if (temp & 0xffffff00L) {
-	/* handle overflow over all buffered 0xff bytes */
-	if (s->buffer >= 0) {
-	  ++s->buffer;
-	  s->byte_out(s->buffer, s->file);
-	  if (s->buffer == MARKER_ESC)
-	    s->byte_out(MARKER_STUFF, s->file);
-	}
-	for (; s->sc; --s->sc)
-	  s->byte_out(0x00, s->file);
-	s->buffer = temp & 0xff;  /* new output byte, might overflow later */
-	assert(s->buffer != 0xff);
-	/* can s->buffer really never become 0xff here? */
-      } else if (temp == 0xff) {
-	/* buffer 0xff byte (which might overflow later) */
-	++s->sc;
-      } else {
-	/* output all buffered 0xff bytes, they will not overflow any more */
-	if (s->buffer >= 0)
-	  s->byte_out(s->buffer, s->file);
-	for (; s->sc; --s->sc) {
-	  s->byte_out(0xff, s->file);
-	  s->byte_out(MARKER_STUFF, s->file);
-	}
-	s->buffer = temp;   /* buffer new output byte (can still overflow) */
-      }
-      s->c &= 0x7ffffL;
-      s->ct = 8;
-    }
-  } while (s->a < 0x8000);
- 
-  return;
-}
-
-
-void arith_decode_init(struct jbg_ardec_state *s, int reuse_st)
-{
-  int i;
-  
-  if (!reuse_st)
-    for (i = 0; i < 4096; s->st[i++] = 0);
-  s->c = 0;
-  s->a = 1;
-  s->ct = 0;
-  s->startup = 1;
-  s->nopadding = 0;
-  return;
-}
-
-/*
- * Decode and return one symbol from the provided PSCD byte stream
- * that starts in s->pscd_ptr and ends in the byte before s->pscd_end.
- * The context cx is a 12-bit integer in the range 0..4095. This
- * function will advance s->pscd_ptr each time it has consumed all
- * information from that PSCD byte.
- *
- * If a symbol has been decoded successfully, the return value will be
- * 0 or 1 (depending on the symbol).
- *
- * If the decoder was not able to decode a symbol from the provided
- * PSCD, then the return value will be -1, and two cases can be
- * distinguished:
- *
- * s->pscd_ptr == s->pscd_end:
- *
- *   The decoder has used up all information in the provided PSCD
- *   bytes. Further PSCD bytes have to be provided (via new values of
- *   s->pscd_ptr and/or s->pscd_end) before another symbol can be
- *   decoded.
- *
- * s->pscd_ptr == s->pscd_end - 1:
- * 
- *   The decoder has used up all provided PSCD bytes except for the
- *   very last byte, because that has the value 0xff. The decoder can
- *   at this point not yet tell whether this 0xff belongs to a
- *   MARKER_STUFF sequence or marks the end of the PSCD. Further PSCD
- *   bytes have to be provided (via new values of s->pscd_ptr and/or
- *   s->pscd_end), including the not yet processed 0xff byte, before
- *   another symbol can be decoded successfully.
- *
- * If s->nopadding != 0, the decoder will return -2 when it reaches
- * the first two bytes of the marker segment that follows (and
- * terminates) the PSCD, but before decoding the first symbol that
- * depends on a bit in the input data that could have been the result
- * of zero padding, and might, therefore, never have been encoded.
- * This gives the caller the opportunity to lookahead early enough
- * beyond a terminating SDNORM/SDRST for a trailing NEWLEN (as
- * required by T.85) before decoding remaining symbols. Call the
- * decoder again afterwards as often as necessary (leaving s->pscd_ptr
- * pointing to the start of the marker segment) to retrieve any
- * required remaining symbols that might depend on padding.
- *
- * [Note that each PSCD can be decoded into an infinitely long
- * sequence of symbols, because the encoder might have truncated away
- * an arbitrarily long sequence of trailing 0x00 bytes, which the
- * decoder will append automatically as needed when it reaches the end
- * of the PSCD. Therefore, the decoder cannot report any end of the
- * symbol sequence and other means (external to the PSCD and
- * arithmetic decoding process) are needed to determine that.]
- */
-
-int arith_decode(struct jbg_ardec_state *s, int cx)
-{
-  register unsigned lsz, ss;
-  register unsigned char *st;
-  int pix;
-
-  /* renormalization */
-  while (s->a < 0x8000 || s->startup) {
-    while (s->ct <= 8 && s->ct >= 0) {
-      /* first we can move a new byte into s->c */
-      if (s->pscd_ptr >= s->pscd_end) {
-	return -1;  /* more bytes needed */
-      }
-      if (*s->pscd_ptr == 0xff) 
-	if (s->pscd_ptr + 1 >= s->pscd_end) {
-	  return -1; /* final 0xff byte not processed */
-	} else {
-	  if (*(s->pscd_ptr + 1) == MARKER_STUFF) {
-	    s->c |= 0xffL << (8 - s->ct);
-	    s->ct += 8;
-	    s->pscd_ptr += 2;
-	  } else {
-	    s->ct = -1; /* start padding with zero bytes */
-	    if (s->nopadding) {
-	      s->nopadding = 0;
-	      return -2; /* subsequent symbols might depend on zero padding */
-	    }
-	  }
-	}
-      else {
-	s->c |= (long)*(s->pscd_ptr++) << (8 - s->ct);
-	s->ct += 8;
-      }
-    }
-    s->c <<= 1;
-    s->a <<= 1;
-    if (s->ct >= 0) s->ct--;
-    if (s->a == 0x10000L)
-      s->startup = 0;
-  }
-
-  st = s->st + cx;
-  ss = *st & 0x7f;
-  assert(ss < 113);
-  lsz = lsztab[ss];
-
-#if 0
-  fprintf(stderr, "cx = %d, mps = %d, st = %3d, lsz = 0x%04x, a = 0x%05lx, "
-	  "c = 0x%08lx, ct = %2d\n",
-	  cx, !!(s->st[cx] & 0x80), ss, lsz, s->a, s->c, s->ct);
-#endif
-
-  if ((s->c >> 16) < (s->a -= lsz))
-    if (s->a & 0xffff8000L)
-      return *st >> 7;
-    else {
-      /* MPS_EXCHANGE */
-      if (s->a < lsz) {
-	pix = 1 - (*st >> 7);
-	/* Check whether MPS/LPS exchange is necessary
-	 * and chose next probability estimator status */
-	*st &= 0x80;
-	*st ^= nlpstab[ss];
-      } else {
-	pix = *st >> 7;
-	*st &= 0x80;
-	*st |= nmpstab[ss];
-      }
-    }
-  else {
-    /* LPS_EXCHANGE */
-    if (s->a < lsz) {
-      s->c -= s->a << 16;
-      s->a = lsz;
-      pix = *st >> 7;
-      *st &= 0x80;
-      *st |= nmpstab[ss];
-    } else {
-      s->c -= s->a << 16;
-      s->a = lsz;
-      pix = 1 - (*st >> 7);
-      /* Check whether MPS/LPS exchange is necessary
-       * and chose next probability estimator status */
-      *st &= 0x80;
-      *st ^= nlpstab[ss];
-    }
-  }
-
-  return pix;
-}
diff -uNr foo2zjs-patch1/jbig_ar.h foo2zjs/jbig_ar.h
--- foo2zjs-patch1/jbig_ar.h	2008-09-05 17:05:54.000000000 +0200
+++ foo2zjs/jbig_ar.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/*
- *  Header file for the arithmetic encoder and decoder of
- *  the portable JBIG compression library
- *
- *  Markus Kuhn -- http://www.cl.cam.ac.uk/~mgk25/jbigkit/
- *
- *  $Id: jbig_ar.h,v 1.1 2008/09/05 15:05:54 rick Exp $
- */
-
-#ifndef JBG_AR_H
-#define JBG_AR_H
-
-/*
- * Status of arithmetic encoder
- */
-
-struct jbg_arenc_state {
-  unsigned char st[4096];    /* probability status for contexts, MSB = MPS */
-  unsigned long c;                /* register C: base of coding intervall, *
-                                   * layout as in Table 23                 */
-  unsigned long a;       /* register A: normalized size of coding interval */
-  long sc;     /* number of buffered 0xff values that might still overflow */
-  int ct;  /* bit shift counter, determines when next byte will be written */
-  int buffer;                /* buffer for most recent output byte != 0xff */
-  void (*byte_out)(int, void *);  /* function that receives all PSCD bytes */
-  void *file;                              /* parameter passed to byte_out */
-};
-
-/*
- * Status of arithmetic decoder
- */
-
-struct jbg_ardec_state {
-  unsigned char st[4096];    /* probability status for contexts, MSB = MPS */
-  unsigned long c;                /* register C: base of coding intervall, *
-                                   * layout as in Table 25                 */
-  unsigned long a;       /* register A: normalized size of coding interval */
-  unsigned char *pscd_ptr;               /* pointer to next PSCD data byte */
-  unsigned char *pscd_end;                   /* pointer to byte after PSCD */
-  int ct;    /* bit-shift counter, determines when next byte will be read;
-              * special value -1 signals that zero-padding has started     */
-  int startup;          /* boolean flag that controls initial fill of s->c */
-  int nopadding;        /* boolean flag that triggers return -2 between
-			 * reaching PSCD end and decoding the first symbol
-			 * that might never have been encoded in the first
-			 * place */
-};
-
-void arith_encode_init(struct jbg_arenc_state *s, int reuse_st);
-void arith_encode_flush(struct jbg_arenc_state *s);
-void arith_encode(struct jbg_arenc_state *s, int cx, int pix);
-void arith_decode_init(struct jbg_ardec_state *s, int reuse_st);
-int  arith_decode(struct jbg_ardec_state *s, int cx);
-
-#endif /* JBG_AR_H */
diff -uNr foo2zjs-patch1/jbig.c foo2zjs/jbig.c
--- foo2zjs-patch1/jbig.c	2011-06-09 13:54:12.000000000 +0200
+++ foo2zjs/jbig.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3289 +0,0 @@
-/*
- *  Portable JBIG image compression library
- *
- *  Copyright 1995-2007 -- Markus Kuhn -- http://www.cl.cam.ac.uk/~mgk25/
- *
- *  $Id: jbig.c,v 1.6 2011/06/09 11:54:12 rick Exp $
- *
- *  This module implements a portable standard C encoder and decoder
- *  using the JBIG1 lossless bi-level image compression algorithm
- *  specified in International Standard ISO 11544:1993 and
- *  ITU-T Recommendation T.82. See the file jbig.txt for usage
- *  instructions and application examples.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- * 
- *  If you want to use this program under different license conditions,
- *  then contact the author for an arrangement.
- *
- *  It is possible that certain products which can be built using this
- *  software module might form inventions protected by patent rights in
- *  some countries (e.g., by patents about arithmetic coding algorithms
- *  owned by IBM and AT&T in the USA). Provision of this software by the
- *  author does NOT include any licences for any patents. In those
- *  countries where a patent licence is required for certain applications
- *  of this software module, you will have to obtain such a licence
- *  yourself.
- */
-
-#ifdef DEBUG
-#include <stdio.h>
-#else
-#define NDEBUG
-#endif
-
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#include "jbig.h"
-
-#define MX_MAX  127    /* maximal supported mx offset for
-			* adaptive template in the encoder */
-
-#define TPB2CX  0x195  /* contexts for TP special pixels */
-#define TPB3CX  0x0e5
-#define TPDCX   0xc3f
-
-/* marker codes */
-#define MARKER_STUFF    0x00
-#define MARKER_RESERVE  0x01
-#define MARKER_SDNORM   0x02
-#define MARKER_SDRST    0x03
-#define MARKER_ABORT    0x04
-#define MARKER_NEWLEN   0x05
-#define MARKER_ATMOVE   0x06
-#define MARKER_COMMENT  0x07
-#define MARKER_ESC      0xff
-
-/* loop array indices */
-#define STRIPE  0
-#define LAYER   1
-#define PLANE   2
-
-/* special jbg_buf pointers (instead of NULL) */
-#define SDE_DONE ((struct jbg_buf *) -1)
-#define SDE_TODO ((struct jbg_buf *) 0)
-
-/* object code version id */
-
-const char jbg_version[] = 
-  "JBIG-KIT " JBG_VERSION " -- (c) 1995-2008 Markus Kuhn -- "
-  "Licence: " JBG_LICENCE "\n"
-  "$Id: jbig.c,v 1.6 2011/06/09 11:54:12 rick Exp $ ";
-
-/*
- * the following array specifies for each combination of the 3
- * ordering bits, which ii[] variable represents which dimension
- * of s->sde.
- */
-static const int iindex[8][3] = {
-  { 2, 1, 0 },    /* no ordering bit set */
-  { -1, -1, -1},  /* SMID -> illegal combination */
-  { 2, 0, 1 },    /* ILEAVE */
-  { 1, 0, 2 },    /* SMID + ILEAVE */
-  { 0, 2, 1 },    /* SEQ */
-  { 1, 2, 0 },    /* SEQ + SMID */
-  { 0, 1, 2 },    /* SEQ + ILEAVE */
-  { -1, -1, -1 }  /* SEQ + SMID + ILEAVE -> illegal combination */
-};
-
-#define _(String) String  /* to mark translatable string for GNU gettext */
-
-/*
- * Array with English ASCII error messages that correspond
- * to return values from public functions in this library.
- */
-static const char *errmsg[] = {
-  _("All OK"),                                               /* JBG_EOK */
-  _("Reached specified image size"),                         /* JBG_EOK_INTR */
-  _("Unexpected end of input data stream"),                  /* JBG_EAGAIN */
-  _("Not enough memory available"),                          /* JBG_ENOMEM */
-  _("ABORT marker segment encountered"),                     /* JBG_EABORT */
-  _("Unknown marker segment encountered"),                   /* JBG_EMARKER */
-  _("Input data stream contains invalid data"),              /* JBG_EINVAL */
-  _("Input data stream uses unimplemented JBIG features"),   /* JBG_EIMPL */
-  _("Incremental BIE does not continue previous one")        /* JBG_ENOCONT */
-};
-
-
-/*
- * The following three functions are the only places in this code, were
- * C library memory management functions are called. The whole JBIG
- * library has been designed in order to allow multi-threaded
- * execution. No static or global variables are used, so all fuctions
- * are fully reentrant. However if you want to use this multi-thread
- * capability and your malloc, realloc and free are not reentrant,
- * then simply add the necessary semaphores or mutex primitives below.
- * In contrast to C's malloc() and realloc(), but like C's calloc(),
- * these functions take two parameters nmemb and size that are multiplied
- * before being passed on to the corresponding C function. 
- * This we can catch all overflows during a size_t multiplication a
- * a single place.
- */
-
-#ifndef SIZE_MAX
-#define SIZE_MAX ((size_t) -1)     /* largest value of size_t */
-#endif
-
-static void *checked_malloc(size_t nmemb, size_t size)
-{
-  void *p;
-
-  /* Full manual exception handling is ugly here for performance
-   * reasons. If an adequate handling of lack of memory is required,
-   * then use C++ and throw a C++ exception instead of abort(). */
-
-  /* assert that nmemb * size <= SIZE_MAX */
-  if (size > SIZE_MAX / nmemb)
-    abort();
-  
-  p = malloc(nmemb * size);
-
-  if (!p)
-    abort();
-
-#if 0
-  fprintf(stderr, "%p = malloc(%lu * %lu)\n", p,
-	  (unsigned long) nmemb, (unsigned long) size);
-#endif
-
-  return p;
-}
-
-
-static void *checked_realloc(void *ptr, size_t nmemb, size_t size)
-{
-  void *p;
-
-  /* Full manual exception handling is ugly here for performance
-   * reasons. If an adequate handling of lack of memory is required,
-   * then use C++ and throw a C++ exception here instead of abort(). */
-
-  /* assert that nmemb * size <= SIZE_MAX */
-  if (size > SIZE_MAX / nmemb)
-    abort();
-  
-  p = realloc(ptr, nmemb * size);
-
-  if (!p)
-    abort();
-
-#if 0
-  fprintf(stderr, "%p = realloc(%p, %lu * %lu)\n", p, ptr,
-	  (unsigned long) nmemb, (unsigned long) size);
-#endif
-
-  return p;
-}
-
-
-static void checked_free(void *ptr)
-{
-  free(ptr);
-
-#if 0
-  fprintf(stderr, "free(%p)\n", ptr);
-#endif
-
-}
-
-
-
-
-/*
- * Memory management for buffers which are used for temporarily
- * storing SDEs by the encoder.
- *
- * The following functions manage a set of struct jbg_buf storage
- * containers were each can keep JBG_BUFSIZE bytes. The jbg_buf
- * containers can be linked to form linear double-chained lists for
- * which a number of operations are provided. Blocks which are
- * tempoarily not used any more are returned to a freelist which each
- * encoder keeps. Only the destructor of the encoder actually returns
- * the block via checked_free() to the stdlib memory management.
- */
-
-
-/*
- * Allocate a new buffer block and initialize it. Try to get it from
- * the free_list, and if it is empty, call checked_malloc().
- */
-static struct jbg_buf *jbg_buf_init(struct jbg_buf **free_list)
-{
-  struct jbg_buf *new_block;
-  
-  /* Test whether a block from the free list is available */
-  if (*free_list) {
-    new_block = *free_list;
-    *free_list = new_block->next;
-  } else {
-    /* request a new memory block */
-    new_block = (struct jbg_buf *) checked_malloc(1, sizeof(struct jbg_buf));
-  }
-  new_block->len = 0;
-  new_block->next = NULL;
-  new_block->previous = NULL;
-  new_block->last = new_block;
-  new_block->free_list = free_list;
-
-  return new_block;
-}
-
-
-/*
- * Return an entire free_list to the memory management of stdlib.
- * This is only done by jbg_enc_free().
- */
-static void jbg_buf_free(struct jbg_buf **free_list)
-{
-  struct jbg_buf *tmp;
-  
-  while (*free_list) {
-    tmp = (*free_list)->next;
-    checked_free(*free_list);
-    *free_list = tmp;
-  }
-  
-  return;
-}
-
-
-/*
- * Append a single byte to a single list that starts with the block
- * *(struct jbg_buf *) head. The type of *head is void here in order to
- * keep the interface of the arithmetic encoder gereric, which uses this
- * function as a call-back function in order to deliver single bytes
- * for a PSCD.
- */
-static void jbg_buf_write(int b, void *head)
-{
-  struct jbg_buf *now;
-
-  now = ((struct jbg_buf *) head)->last;
-  if (now->len < JBG_BUFSIZE - 1) {
-    now->d[now->len++] = b;
-    return;
-  }
-  now->next = jbg_buf_init(((struct jbg_buf *) head)->free_list);
-  now->next->previous = now;
-  now->next->d[now->next->len++] = b;
-  ((struct jbg_buf *) head)->last = now->next;
-
-  return;
-}
-
-
-/*
- * Remove any trailing zero bytes from the end of a linked jbg_buf list,
- * however make sure that no zero byte is removed which directly
- * follows a 0xff byte (i.e., keep MARKER_ESC MARKER_STUFF sequences
- * intact). This function is used to remove any redundant final zero
- * bytes from a PSCD.
- */
-static void jbg_buf_remove_zeros(struct jbg_buf *head)
-{
-  struct jbg_buf *last;
-
-  while (1) {
-    /* remove trailing 0x00 in last block of list until this block is empty */
-    last = head->last;
-    while (last->len && last->d[last->len - 1] == 0)
-      last->len--;
-    /* if block became really empty, remove it in case it is not the
-     * only remaining block and then loop to next block */
-    if (last->previous && !last->len) {
-      head->last->next = *head->free_list;
-      *head->free_list = head->last;
-      head->last = last->previous;
-      head->last->next = NULL;
-    } else
-      break;
-  }
-
-  /*
-   * If the final non-zero byte is 0xff (MARKER_ESC), then we just have
-   * removed a MARKER_STUFF and we will append it again now in order
-   * to preserve PSCD status of byte stream.
-   */
-  if (head->last->len && head->last->d[head->last->len - 1] == MARKER_ESC)
-    jbg_buf_write(MARKER_STUFF, head);
- 
-  return;
-}
-
-
-/*
- * The jbg_buf list which starts with block *new_prefix is concatenated
- * with the list which starts with block **start and *start will then point
- * to the first block of the new list.
- */
-static void jbg_buf_prefix(struct jbg_buf *new_prefix, struct jbg_buf **start)
-{
-  new_prefix->last->next = *start;
-  new_prefix->last->next->previous = new_prefix->last;
-  new_prefix->last = new_prefix->last->next->last;
-  *start = new_prefix;
-  
-  return;
-}
-
-
-/*
- * Send the contents of a jbg_buf list that starts with block **head to
- * the call back function data_out and return the blocks of the jbg_buf
- * list to the freelist from which these jbg_buf blocks have been taken.
- * After the call, *head == NULL.
- */
-static void jbg_buf_output(struct jbg_buf **head,
-			void (*data_out)(unsigned char *start,
-					 size_t len, void *file),
-			void *file)
-{
-  struct jbg_buf *tmp;
-  
-  while (*head) {
-    data_out((*head)->d, (*head)->len, file);
-    tmp = (*head)->next;
-    (*head)->next = *(*head)->free_list;
-    *(*head)->free_list = *head;
-    *head = tmp;
-  }
-  
-  return;
-}
-
-
-/*
- * Calculate y = ceil(x/2) applied n times, which is equivalent to
- * y = ceil(x/(2^n)). This function is used to
- * determine the number of pixels per row or column after n resolution
- * reductions. E.g. X[d-1] = jbg_ceil_half(X[d], 1) and X[0] =
- * jbg_ceil_half(X[d], d) as defined in clause 6.2.3 of T.82.
- */
-unsigned long jbg_ceil_half(unsigned long x, int n)
-{
-  unsigned long mask;
-  
-  assert(n >= 0 && n < 32);
-  mask = (1UL << n) - 1;     /* the lowest n bits are 1 here */
-  return (x >> n) + ((mask & x) != 0);
-}
-
-
-/*
- * Set L0 (the number of lines in a stripe at lowest resolution)
- * to a default value, such that there are about 35 stripes, as
- * suggested in Annex C of ITU-T T.82, without exceeding the
- * limit 128/2^D suggested in Annex A.
- */
-static void jbg_set_default_l0(struct jbg_enc_state *s)
-{
-  s->l0 = jbg_ceil_half(s->yd, s->d) / 35;   /* 35 stripes/image */
-  while ((s->l0 << s->d) > 128)              /* but <= 128 lines/stripe */
-    --s->l0;
-  if (s->l0 < 2) s->l0 = 2;
-}
-
-
-/*
- * Calculate the number of stripes, as defined in clause 6.2.3 of T.82.
- */
-unsigned long jbg_stripes(unsigned long l0, unsigned long yd,
-			  unsigned long d)
-{
-  unsigned long y0 = jbg_ceil_half(yd, d);
-
-  return y0 / l0 + (y0 % l0 != 0);
-}
-
-
-/*
- * Resolution reduction table given by ITU-T T.82 Table 17
- */
-
-static char jbg_resred[4096] = {
-  0,0,0,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,
-  0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,
-  0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,
-  1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,
-  0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,1,0,0,0,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,
-  1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,
-  1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,
-  0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,
-  1,0,0,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,
-  0,0,1,0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,
-  0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,
-  0,0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,
-  0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,
-  0,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,
-  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,1,1,1,
-  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,1,1,1,0,1,1,0,0,1,1,
-  0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,
-  0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,0,1,1,
-  0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,
-  1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,1,1,0,1,1,1,
-  0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,
-  1,1,1,0,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,
-  1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,0,1,1,
-  0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,
-  1,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,0,1,1,0,
-  0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
-  0,0,1,0,1,0,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,
-  0,0,1,0,1,0,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,
-  0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
-  0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,1,
-  0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,
-  1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,
-  0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,
-  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,
-  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,
-  0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1
-};
-
-/*
- * Deterministic prediction tables given by ITU-T T.82 tables
- * 19 to 22. The table below is organized differently, the
- * index bits are permutated for higher efficiency.
- */
-
-static char jbg_dptable[256 + 512 + 2048 + 4096] = {
-  /* phase 0: offset=0 */
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,
-  0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,0,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  /* phase 1: offset=256 */
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,0,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,2,1,2,1,2,2,2,2,1,1,1,1,2,0,2,0,2,2,2,2,0,2,0,2,2,2,2,2,
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,
-  0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,
-  0,2,2,2,2,1,2,1,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
-  1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,1,2,2,2,2,2,0,2,2,2,2,2,2,
-  2,2,2,2,2,0,2,0,2,2,2,2,0,0,0,0,0,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,
-  0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,0,2,0,2,2,2,2,2,
-  2,2,2,2,2,1,1,1,2,2,2,2,1,1,1,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,0,2,0,2,2,2,2,2,0,2,0,2,2,2,2,1,
-  0,2,0,2,2,1,2,1,2,2,2,2,1,1,1,1,0,0,0,0,2,2,2,2,0,2,0,2,2,2,2,1,
-  2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,2,2,2,2,2,
-  2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,1,
-  2,2,2,2,2,2,2,2,0,2,0,2,2,1,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,
-  /* phase 2: offset=768 */
-  2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,
-  0,2,2,2,2,1,2,1,2,2,2,2,1,2,1,2,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,2,1,2,2,2,2,2,1,1,1,
-  2,0,2,2,2,1,2,1,0,2,2,2,1,2,1,2,2,2,2,0,2,2,2,2,0,2,0,2,2,2,2,2,
-  0,2,0,0,1,1,1,1,2,2,2,2,1,1,1,1,0,2,0,2,1,1,1,1,2,2,2,2,1,1,1,1,
-  2,2,0,2,2,2,1,2,2,2,2,2,1,2,1,2,2,2,0,2,2,1,2,1,0,2,0,2,1,1,1,1,
-  2,0,0,2,2,2,2,2,0,2,0,2,2,0,2,0,2,0,2,0,2,2,2,1,2,2,0,2,1,1,2,1,
-  2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,
-  0,0,0,0,2,2,2,2,0,0,0,0,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,0,2,2,2,2,1,0,2,2,2,1,1,1,1,2,0,2,2,2,2,2,2,0,2,0,2,2,1,2,1,
-  2,0,2,0,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,
-  0,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,2,2,1,2,1,0,2,2,2,1,1,1,1,
-  2,2,2,0,2,2,2,2,2,2,0,2,2,0,2,0,2,1,2,2,2,2,2,2,1,2,1,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,1,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,1,1,2,2,2,2,1,1,1,1,
-  2,2,2,1,2,2,2,2,2,2,1,2,0,0,0,0,2,2,0,2,2,1,2,2,2,2,2,2,1,1,1,1,
-  2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,1,
-  0,2,0,2,2,1,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,
-  2,0,2,0,2,1,2,1,0,2,0,2,2,2,1,2,2,0,2,0,2,2,2,2,0,2,0,2,2,2,1,2,
-  2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,1,2,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  0,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,2,1,0,2,2,2,1,1,1,1,
-  2,0,2,0,2,1,2,2,0,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,2,2,
-  2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,0,2,2,2,2,0,0,0,0,2,1,2,1,
-  2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,0,0,2,2,2,1,2,2,2,
-  0,0,2,0,2,2,2,2,0,2,0,2,2,0,2,0,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,1,
-  2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,1,1,1,1,
-  0,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  2,0,0,2,2,2,2,2,0,2,0,2,2,2,2,2,1,0,1,2,2,2,2,1,0,2,2,2,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,0,2,2,0,2,0,2,1,2,2,2,2,2,2,2,2,0,2,2,1,2,2,
-  0,2,0,0,1,1,1,1,0,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,0,2,2,1,2,1,1,
-  2,2,0,2,2,1,2,2,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,2,0,2,0,2,1,2,1,1,
-  2,0,2,0,2,2,2,2,0,2,0,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,2,0,2,0,2,2,2,2,0,0,0,0,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,
-  2,0,2,2,2,1,2,1,0,2,2,2,2,2,1,2,2,0,2,0,2,2,2,2,0,2,0,2,2,1,2,2,
-  0,2,0,0,2,2,2,2,1,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,
-  0,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,0,2,2,
-  0,0,0,2,2,1,1,1,2,2,2,2,1,2,2,2,2,0,2,0,2,2,2,1,2,2,2,2,1,2,1,2,
-  0,0,0,0,2,2,2,2,2,2,0,2,2,1,2,2,2,1,2,1,2,2,2,2,1,2,1,2,0,2,2,2,
-  2,0,2,0,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  0,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,1,2,2,2,2,2,0,2,2,1,2,2,0,0,0,2,2,2,2,2,1,2,2,0,2,2,2,1,2,1,2,
-  2,0,2,0,2,2,2,2,0,2,0,2,2,1,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,1,
-  1,2,0,2,2,1,2,1,2,2,2,2,1,2,2,2,2,0,2,0,2,2,2,2,2,0,2,2,1,1,1,1,
-  0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,1,2,1,
-  2,2,0,0,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
-  2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,
-  2,0,2,0,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,2,0,2,2,2,1,2,
-  2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,0,2,0,2,2,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,2,2,2,0,0,0,0,2,1,2,1,
-  2,2,2,2,2,1,2,1,0,2,0,2,2,2,2,2,2,0,2,0,2,2,2,2,0,2,0,2,2,2,2,1,
-  2,0,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,0,
-  2,0,2,0,2,2,2,1,2,2,2,0,2,2,2,1,2,0,2,0,2,2,2,2,0,0,0,2,2,2,2,1,
-  2,0,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,
-  /* phase 3: offset=2816 */
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,1,2,1,2,0,2,0,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,0,2,2,2,1,2,0,2,2,2,1,2,2,2,2,0,2,0,2,1,2,1,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,
-  2,2,2,1,2,2,2,0,1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,2,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,2,0,2,0,2,1,2,1,
-  2,0,0,0,2,1,1,1,0,0,0,0,1,1,1,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,
-  2,0,2,2,2,1,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,0,0,2,0,1,1,2,1,
-  2,2,2,0,2,2,2,1,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,
-  0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,2,0,2,0,2,1,2,1,0,0,0,0,1,1,1,1,
-  2,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,2,1,1,1,2,0,0,0,
-  2,1,2,1,2,0,2,0,1,2,1,2,0,2,0,2,2,2,2,0,2,2,2,1,2,0,2,0,2,1,2,1,
-  2,0,2,0,2,1,2,1,0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,
-  2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  2,0,0,0,2,1,1,1,0,0,0,0,1,1,1,1,2,0,2,0,2,1,2,1,0,0,2,0,1,1,2,1,
-  2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,0,0,0,2,1,1,1,
-  2,2,2,1,2,2,2,0,2,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,1,2,1,2,0,2,0,2,
-  2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,0,0,0,0,1,1,1,1,
-  2,0,2,2,2,1,2,2,0,0,2,0,1,1,2,1,2,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,0,0,0,0,1,1,1,1,
-  2,0,0,0,2,1,1,1,0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,2,1,0,2,2,0,1,2,
-  2,2,2,1,2,2,2,0,2,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,
-  2,1,2,1,2,0,2,0,1,2,1,1,0,2,0,0,0,0,2,1,1,1,2,0,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,0,2,1,2,1,2,0,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,0,2,2,2,1,2,2,2,0,0,2,2,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,
-  2,0,2,0,2,1,2,1,0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,0,0,0,0,1,1,1,1,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,0,0,0,2,1,1,1,
-  2,2,2,0,2,2,2,1,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,0,2,2,2,1,2,2,2,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,1,2,1,2,0,2,0,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,1,2,1,2,0,2,0,1,2,1,1,0,2,0,0,2,0,2,2,2,1,2,2,0,2,1,2,1,2,0,2,
-  2,2,2,1,2,2,2,0,2,2,1,2,2,2,0,2,2,1,2,2,2,0,2,2,2,2,0,2,2,2,1,2,
-  0,0,2,0,1,1,2,1,0,0,1,0,1,1,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,0,2,2,2,1,1,2,2,2,0,2,2,2,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,0,0,2,2,1,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,
-  2,0,0,0,2,1,1,1,0,0,0,0,1,1,1,1,2,2,2,1,2,2,2,0,2,1,2,1,2,0,2,0,
-  2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,1,2,1,1,2,0,0,0,2,1,1,1,
-  2,2,2,2,2,2,2,2,2,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,1,2,1,2,0,2,0,2,0,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,1,1,1,2,0,0,0,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,0,0,1,2,1,1,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,2,
-  2,1,2,1,2,0,2,0,2,1,2,2,2,0,2,2,2,2,2,0,2,2,2,1,2,0,2,0,2,1,2,1,
-  2,0,2,0,2,1,2,1,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,0,1,0,0,1,0,1,1,
-  2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,1,0,2,0,2,2,2,1,2,2,2,
-  2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,
-  2,0,2,0,2,1,2,1,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  0,2,0,0,1,2,1,1,2,0,0,0,2,1,1,1,2,2,2,2,2,2,2,2,1,0,1,2,0,1,0,2,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,1,2,2,2,0,2,2,1,1,2,2,0,0,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,1,2,1,2,0,2,0,2,1,2,2,2,0,2,2,2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,0,2,2,2,
-  2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,2,
-  0,0,0,0,1,1,1,1,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,2,2,0,2,2,2,1,2,
-  2,0,2,0,2,1,2,1,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,
-  0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,1,2,2,2,0,1,1,2,1,0,0,2,0,2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,0,2,2,2,1,2,
-  2,0,2,0,2,1,2,1,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,
-  0,2,0,0,1,2,1,1,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,2,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,0,0,2,1,1,1,2,0,0,2,2,2,1,2,2,2,
-  2,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,1,2,1,1,
-  0,0,2,2,1,1,2,2,0,2,1,2,1,2,0,2,2,1,2,1,2,0,2,0,1,2,1,2,0,2,0,2,
-  2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,
-  2,2,0,0,2,2,1,1,2,2,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,1,
-  2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,1,2,1,1,
-  2,2,2,0,2,2,2,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,2,0,0,0,2,
-  2,2,2,2,2,2,2,2,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,
-  2,0,2,0,2,1,2,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,
-  2,0,2,2,2,1,2,2,0,2,2,2,1,2,2,2,2,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,
-  2,0,2,0,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,0,2,0,2,1,2,1,2,1,2,0,2,0,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,0,2,0,2,1,2,1,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,1,2,1,2,0,2,0,2,2,1,2,1,2,0,2,0,2,2,2,2,2,2,2,2,
-  2,0,2,1,2,1,2,0,0,2,1,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,0,2,0,2,1,2,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,1,
-  2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,1,2,1,2,0,2,0,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,
-  2,0,2,0,2,1,2,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-  2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
-};
-
-
-/*
- * Initialize the status struct for the encoder.
- */
-void jbg_enc_init(struct jbg_enc_state *s, unsigned long x, unsigned long y,
-                  int planes, unsigned char **p,
-                  void (*data_out)(unsigned char *start, size_t len,
-				   void *file),
-		  void *file)
-{
-  unsigned long l, lx;
-  int i;
-
-  assert(x > 0 && y > 0 && planes > 0 && planes < 256);
-  s->xd = x;
-  s->yd = y;
-  s->yd1 = y; /* This is the hight initially announced in BIH. To provoke
-                 generation of NEWLEN for T.85 compatibility tests,
-                 overwrite with new value s->yd1 > s->yd  */
-  s->planes = planes;
-  s->data_out = data_out;
-  s->file = file;
-
-  s->d = 0;
-  s->dl = 0;
-  s->dh = s->d;
-  jbg_set_default_l0(s);
-  s->mx = 8;
-  s->my = 0;
-  s->order = JBG_ILEAVE | JBG_SMID;
-  s->options = JBG_TPBON | JBG_TPDON | JBG_DPON;
-  s->comment = NULL;
-  s->dppriv = jbg_dptable;
-  s->res_tab = jbg_resred;
-  
-  s->highres = (int *) checked_malloc(planes, sizeof(int));
-  s->lhp[0] = p;
-  s->lhp[1] = (unsigned char **)
-    checked_malloc(planes, sizeof(unsigned char *));
-  for (i = 0; i < planes; i++) {
-    s->highres[i] = 0;
-    s->lhp[1][i] = (unsigned char *)
-      checked_malloc(jbg_ceil_half(y, 1), jbg_ceil_half(x, 1+3));
-  }
-  
-  s->free_list = NULL;
-  s->s = (struct jbg_arenc_state *) 
-    checked_malloc(s->planes, sizeof(struct jbg_arenc_state));
-  s->tx = (int *) checked_malloc(s->planes, sizeof(int));
-  lx = jbg_ceil_half(x, 1);
-  s->tp = (char *) checked_malloc(lx, sizeof(char));
-  for (l = 0; l < lx; s->tp[l++] = 2);
-  s->sde = NULL;
-
-  return;
-}
-
-
-/*
- * This function selects the number of differential layers based on
- * the maximum size requested for the lowest resolution layer. If
- * possible, a number of differential layers is selected, which will
- * keep the size of the lowest resolution layer below or equal to the
- * given width x and height y. However not more than 6 differential
- * resolution layers will be used. In addition, a reasonable value for
- * l0 (height of one stripe in the lowest resolution layer) is
- * selected, which obeys the recommended limitations for l0 in annex A
- * and C of the JBIG standard. The selected number of resolution layers
- * is returned. 
- */
-int jbg_enc_lrlmax(struct jbg_enc_state *s, unsigned long x, 
-		   unsigned long y)
-{
-  for (s->d = 0; s->d < 6; s->d++)
-    if (jbg_ceil_half(s->xd, s->d) <= x && jbg_ceil_half(s->yd, s->d) <= y)
-      break;
-  s->dl = 0;
-  s->dh = s->d;
-  jbg_set_default_l0(s);
-  return s->d;
-}
-
-
-/*
- * As an alternative to jbg_enc_lrlmax(), the following function allows
- * to specify the number of layers directly. The stripe height and layer
- * range is also adjusted automatically here.
- */
-void jbg_enc_layers(struct jbg_enc_state *s, int d)
-{
-  if (d < 0 || d > 31)
-    return;
-  s->d  = d;
-  s->dl = 0;
-  s->dh = s->d;
-  jbg_set_default_l0(s);
-  return;
-}
-
-
-/*
- * Specify the highest and lowest resolution layers which will be
- * written to the output file. Call this function not before
- * jbg_enc_layers() or jbg_enc_lrlmax(), because these two functions
- * reset the lowest and highest resolution layer to default values.
- * Negative values are ignored. The total number of layers is returned.
- */
-int jbg_enc_lrange(struct jbg_enc_state *s, int dl, int dh)
-{
-  if (dl >= 0     && dl <= s->d) s->dl = dl;
-  if (dh >= s->dl && dh <= s->d) s->dh = dh;
-
-  return s->d;
-}
-
-
-/*
- * The following function allows to specify the bits describing the
- * options of the format as well as the maximum AT movement window and
- * the number of layer 0 lines per stripes.
- */
-void jbg_enc_options(struct jbg_enc_state *s, int order, int options,
-		     unsigned long l0, int mx, int my)
-{
-  if (order >= 0 && order <= 0x0f) s->order = order;
-  if (options >= 0) s->options = options;
-  if (l0 > 0) s->l0 = l0;
-  if (mx >= 0 && my < 128) s->mx = mx;
-  if (my >= 0 && my < 256) s->my = my;
-
-  return;
-}
-
-
-/*
- * This function actually does all the tricky work involved in producing
- * a SDE, which is stored in the appropriate s->sde[][][] element
- * for later output in the correct order.
- */
-static void encode_sde(struct jbg_enc_state *s,
-		       long stripe, int layer, int plane)
-{
-  unsigned char *hp, *lp1, *lp2, *p0, *p1, *q1, *q2;
-  unsigned long hl, ll, hx, hy, lx, ly, hbpl, lbpl;
-  unsigned long line_h0 = 0, line_h1 = 0;
-  unsigned long line_h2, line_h3, line_l1, line_l2, line_l3;
-  struct jbg_arenc_state *se;
-  unsigned long y;  /* current line number in highres image */
-  unsigned long i;  /* current line number within highres stripe */
-  unsigned long j;  /* current column number in highres image */
-  long o;
-  unsigned a, p, t;
-  int ltp, ltp_old, cx;
-  unsigned long c_all, c[MX_MAX + 1], cmin, cmax, clmin, clmax;
-  int tmax, at_determined;
-  int new_tx;
-  long new_tx_line = -1;
-  int reset;
-  struct jbg_buf *new_jbg_buf;
-
-#ifdef DEBUG
-  static long tp_lines, tp_exceptions, tp_pixels, dp_pixels;
-  static long encoded_pixels;
-#endif
-
-  /* return immediately if this stripe has already been encoded */
-  if (s->sde[stripe][layer][plane] != SDE_TODO)
-    return;
-
-#ifdef DEBUG
-  if (stripe == 0)
-    tp_lines = tp_exceptions = tp_pixels = dp_pixels = encoded_pixels = 0;
-  fprintf(stderr, "encode_sde: s/d/p = %2ld/%2d/%2d\n",
-	  stripe, layer, plane);
-#endif
-
-  /* number of lines per stripe in highres image */
-  hl = s->l0 << layer;
-  /* number of lines per stripe in lowres image */
-  ll = hl >> 1;
-  /* current line number in highres image */
-  y = stripe * hl;
-  /* number of pixels in highres image */
-  hx = jbg_ceil_half(s->xd, s->d - layer);
-  hy = jbg_ceil_half(s->yd, s->d - layer);
-  /* number of pixels in lowres image */
-  lx = jbg_ceil_half(hx, 1);
-  ly = jbg_ceil_half(hy, 1);
-  /* bytes per line in highres and lowres image */
-  hbpl = jbg_ceil_half(hx, 3);
-  lbpl = jbg_ceil_half(lx, 3);
-  /* pointer to first image byte of highres stripe */
-  hp = s->lhp[s->highres[plane]][plane] + stripe * hl * hbpl;
-  lp2 = s->lhp[1 - s->highres[plane]][plane] + stripe * ll * lbpl;
-  lp1 = lp2 + lbpl;
-  
-  /* check whether we can refer to any state of a previous stripe */
-  reset = (stripe == 0) || (s->options & JBG_SDRST);
-
-  /* initialize arithmetic encoder */
-  se = s->s + plane;
-  arith_encode_init(se, !reset);
-  s->sde[stripe][layer][plane] = jbg_buf_init(&s->free_list);
-  se->byte_out = jbg_buf_write;
-  se->file = s->sde[stripe][layer][plane];
-
-  /* initialize adaptive template movement algorithm */
-  c_all = 0;
-  for (t = 0; t <= s->mx; t++)
-    c[t] = 0;
-  if (stripe == 0)    /* the SDRST case is handled at the end */
-    s->tx[plane] = 0;
-  new_tx = -1;
-  at_determined = 0;  /* we haven't yet decided the template move */
-  if (s->mx == 0)
-    at_determined = 1;
-
-  /* initialize typical prediction */
-  ltp = 0;
-  if (reset)
-    ltp_old = 0;
-  else {
-    ltp_old = 1;
-    p1 = hp - hbpl;
-    if (y > 1) {
-      q1 = p1 - hbpl;
-      while (p1 < hp && (ltp_old = (*p1++ == *q1++)) != 0);
-    } else
-      while (p1 < hp && (ltp_old = (*p1++ == 0)) != 0);
-  }
-
-  if (layer == 0) {
-
-    /*
-     *  Encode lowest resolution layer
-     */
-
-    for (i = 0; i < hl && y < hy; i++, y++) {
-
-      /* check whether it is worth to perform an ATMOVE */
-      if (!at_determined && c_all > 2048) {
-	cmin = clmin = 0xffffffffL;
-	cmax = clmax = 0;
-	tmax = 0;
-	for (t = (s->options & JBG_LRLTWO) ? 5 : 3; t <= s->mx; t++) {
-	  if (c[t] > cmax) cmax = c[t];
-	  if (c[t] < cmin) cmin = c[t];
-	  if (c[t] > c[tmax]) tmax = t;
-	}
-	clmin = (c[0] < cmin) ? c[0] : cmin;
-	clmax = (c[0] > cmax) ? c[0] : cmax;
-	if (c_all - cmax < (c_all >> 3) &&
-	    cmax - c[s->tx[plane]] > c_all - cmax &&
-	    cmax - c[s->tx[plane]] > (c_all >> 4) &&
-	    /*                     ^ T.82 said < here, fixed in Cor.1/25 */
-	    cmax - (c_all - c[s->tx[plane]]) > c_all - cmax &&
-	    cmax - (c_all - c[s->tx[plane]]) > (c_all >> 4) &&
-	    cmax - cmin > (c_all >> 2) &&
-	    (s->tx[plane] || clmax - clmin > (c_all >> 3))) {
-	  /* we have decided to perform an ATMOVE */
-	  new_tx = tmax;
-	  if (!(s->options & JBG_DELAY_AT)) {
-	    new_tx_line = i;
-	    s->tx[plane] = new_tx;
-	  }
-#ifdef DEBUG
-	  fprintf(stderr, "ATMOVE: line=%ld, tx=%d, c_all=%ld\n",
-		  i, new_tx, c_all);
-#endif
-	}
-	at_determined = 1;
-      }
-      assert(s->tx[plane] >= 0); /* i.e., tx can safely be cast to unsigned */
-      
-      /* typical prediction */
-      if (s->options & JBG_TPBON) {
-	ltp = 1;
-	p1 = hp;
-	if (i > 0 || !reset) {
-	  q1 = hp - hbpl;
-	  while (q1 < hp && (ltp = (*p1++ == *q1++)) != 0);
-	} else
-	  while (p1 < hp + hbpl && (ltp = (*p1++ == 0)) != 0);
-	arith_encode(se, (s->options & JBG_LRLTWO) ? TPB2CX : TPB3CX,
-		     ltp == ltp_old);
-#ifdef DEBUG
-	tp_lines += ltp;
-#endif
-	ltp_old = ltp;
-	if (ltp) {
-	  /* skip next line */
-	  hp += hbpl;
-	  continue;
-	}
-      }
-
-      /*
-       * Layout of the variables line_h1, line_h2, line_h3, which contain
-       * as bits the neighbour pixels of the currently coded pixel X:
-       *
-       *          76543210765432107654321076543210     line_h3
-       *          76543210765432107654321076543210     line_h2
-       *  76543210765432107654321X76543210             line_h1
-       */
-      
-      line_h1 = line_h2 = line_h3 = 0;
-      if (i > 0 || !reset) line_h2 = (long)*(hp - hbpl) << 8;
-      if (i > 1 || !reset) line_h3 = (long)*(hp - hbpl - hbpl) << 8;
-      
-      /* encode line */
-      for (j = 0; j < hx; hp++) {
-	line_h1 |= *hp;
-	if (j < hbpl * 8 - 8 && (i > 0 || !reset)) {
-	  line_h2 |= *(hp - hbpl + 1);
-	  if (i > 1 || !reset)
-	    line_h3 |= *(hp - hbpl - hbpl + 1);
-	}
-	if (s->options & JBG_LRLTWO) {
-	  /* two line template */
-	  do {
-	    line_h1 <<= 1;  line_h2 <<= 1;  line_h3 <<= 1;
-	    if (s->tx[plane]) {
-	      if ((unsigned) s->tx[plane] > j)
-		a = 0;
-	      else {
-		o = (j - s->tx[plane]) - (j & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		a <<= 4;
-	      }
-	      assert(s->tx[plane] > 23 ||
-		     a == ((line_h1 >> (4 + s->tx[plane])) & 0x010));
-	      arith_encode(se, (((line_h2 >> 10) & 0x3e0) | a |
-				((line_h1 >>  9) & 0x00f)),
-			   (line_h1 >> 8) & 1);
-	    }
-	    else
-	      arith_encode(se, (((line_h2 >> 10) & 0x3f0) |
-				((line_h1 >>  9) & 0x00f)),
-			   (line_h1 >> 8) & 1);
-#ifdef DEBUG
-	    encoded_pixels++;
-#endif
-	    /* statistics for adaptive template changes */
-	    if (!at_determined && j >= s->mx && j < hx-2) {
-	      p = (line_h1 & 0x100) != 0; /* current pixel value */
-	      c[0] += ((line_h2 & 0x4000) != 0) == p; /* default position */
-	      assert(!(((line_h2 >> 6) ^ line_h1) & 0x100) ==
-		     (((line_h2 & 0x4000) != 0) == p));
-	      for (t = 5; t <= s->mx && t <= j; t++) {
-		o = (j - t) - (j & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		assert(t > 23 ||
-		       (a == p) == !(((line_h1 >> t) ^ line_h1) & 0x100));
-		c[t] += a == p;
-	      }
-	      for (; t <= s->mx; t++) {
-		c[t] += 0 == p;
-	      }
-	      ++c_all;
-	    }
-	  } while (++j & 7 && j < hx);
-	} else {
-	  /* three line template */
-	  do {
-	    line_h1 <<= 1;  line_h2 <<= 1;  line_h3 <<= 1;
-	    if (s->tx[plane]) {
-	      if ((unsigned) s->tx[plane] > j)
-		a = 0;
-	      else {
-		o = (j - s->tx[plane]) - (j & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		a <<= 2;
-	      }
-	      assert(s->tx[plane] > 23 ||
-		     a == ((line_h1 >> (6 + s->tx[plane])) & 0x004));
-	      arith_encode(se, (((line_h3 >>  8) & 0x380) |
-				((line_h2 >> 12) & 0x078) | a |
-				((line_h1 >>  9) & 0x003)),
-			   (line_h1 >> 8) & 1);
-	    } else
-	      arith_encode(se, (((line_h3 >>  8) & 0x380) |
-				((line_h2 >> 12) & 0x07c) |
-				((line_h1 >>  9) & 0x003)),
-			   (line_h1 >> 8) & 1);
-#ifdef DEBUG
-	    encoded_pixels++;
-#endif
-	    /* statistics for adaptive template changes */
-	    if (!at_determined && j >= s->mx && j < hx-2) {
-	      p = (line_h1 & 0x100) != 0; /* current pixel value */
-	      c[0] += ((line_h2 & 0x4000) != 0) == p; /* default position */
-	      assert(!(((line_h2 >> 6) ^ line_h1) & 0x100) ==
-		     (((line_h2 & 0x4000) != 0) == p));
-	      for (t = 3; t <= s->mx && t <= j; t++) {
-		o = (j - t) - (j & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		assert(t > 23 ||
-		       (a == p) == !(((line_h1 >> t) ^ line_h1) & 0x100));
-		c[t] += a == p;
-	      }
-	      for (; t <= s->mx; t++) {
-		c[t] += 0 == p;
-	      }
-	      ++c_all;
-	    }
-	  } while (++j & 7 && j < hx);
-	} /* if (s->options & JBG_LRLTWO) */
-      } /* for (j = ...) */
-    } /* for (i = ...) */
-
-  } else {
-
-    /*
-     *  Encode differential layer
-     */
-    
-    for (i = 0; i < hl && y < hy; i++, y++) {
-
-      /* check whether it is worth to perform an ATMOVE */
-      if (!at_determined && c_all > 2048) {
-	cmin = clmin = 0xffffffffL;
-	cmax = clmax = 0;
-	tmax = 0;
-	for (t = 3; t <= s->mx; t++) {
-	  if (c[t] > cmax) cmax = c[t];
-	  if (c[t] < cmin) cmin = c[t];
-	  if (c[t] > c[tmax]) tmax = t;
-	}
-	clmin = (c[0] < cmin) ? c[0] : cmin;
-	clmax = (c[0] > cmax) ? c[0] : cmax;
-	if (c_all - cmax < (c_all >> 3) &&
-	    cmax - c[s->tx[plane]] > c_all - cmax &&
-	    cmax - c[s->tx[plane]] > (c_all >> 4) &&
-	    /*                     ^ T.82 said < here, fixed in Cor.1/25 */
-	    cmax - (c_all - c[s->tx[plane]]) > c_all - cmax &&
-	    cmax - (c_all - c[s->tx[plane]]) > (c_all >> 4) &&
-	    cmax - cmin > (c_all >> 2) &&
-	    (s->tx[plane] || clmax - clmin > (c_all >> 3))) {
-	  /* we have decided to perform an ATMOVE */
-	  new_tx = tmax;
-	  if (!(s->options & JBG_DELAY_AT)) {
-	    new_tx_line = i;
-	    s->tx[plane] = new_tx;
-	  }
-#ifdef DEBUG
-	  fprintf(stderr, "ATMOVE: line=%ld, tx=%d, c_all=%ld\n",
-		  i, new_tx, c_all);
-#endif
-	}
-	at_determined = 1;
-      }
-      
-      if ((i >> 1) >= ll - 1 || (y >> 1) >= ly - 1)
-	lp1 = lp2;
-
-      /* typical prediction */
-      if (s->options & JBG_TPDON && (i & 1) == 0) {
-	q1 = lp1; q2 = lp2;
-	p0 = p1 = hp;
-	if (i < hl - 1 && y < hy - 1)
-	  p0 = hp + hbpl;
-	if (i > 1 || !reset)
-	  line_l3 = (long)*(q2 - lbpl) << 8;
-	else
-	  line_l3 = 0;
-	line_l2 = (long)*q2 << 8;
-	line_l1 = (long)*q1 << 8;
-	ltp = 1;
-	for (j = 0; j < lx && ltp; q1++, q2++) {
-	  if (j < lbpl * 8 - 8) {
-	    if (i > 1 || !reset)
-	      line_l3 |= *(q2 - lbpl + 1);
-	    line_l2 |= *(q2 + 1);
-	    line_l1 |= *(q1 + 1);
-	  }
-	  do {
-	    if ((j >> 2) < hbpl) {
-	      line_h1 = *(p1++);
-	      line_h0 = *(p0++);
-	    }
-	    do {
-	      line_l3 <<= 1;
-	      line_l2 <<= 1;
-	      line_l1 <<= 1;
-	      line_h1 <<= 2;
-	      line_h0 <<= 2;
-	      cx = (((line_l3 >> 15) & 0x007) |
-		    ((line_l2 >> 12) & 0x038) |
-		    ((line_l1 >> 9)  & 0x1c0));
-	      if (cx == 0x000)
-		if ((line_h1 & 0x300) == 0 && (line_h0 & 0x300) == 0)
-		  s->tp[j] = 0;
-		else {
-		  ltp = 0;
-#ifdef DEBUG
-		  tp_exceptions++;
-#endif
-		}
-	      else if (cx == 0x1ff)
-		if ((line_h1 & 0x300) == 0x300 && (line_h0 & 0x300) == 0x300)
-		  s->tp[j] = 1;
-		else {
-		  ltp = 0;
-#ifdef DEBUG
-		  tp_exceptions++;
-#endif
-		}
-	      else
-		s->tp[j] = 2;
-	    } while (++j & 3 && j < lx);
-	  } while (j & 7 && j < lx);
-	} /* for (j = ...) */
-	arith_encode(se, TPDCX, !ltp);
-#ifdef DEBUG
-	tp_lines += ltp;
-#endif
-      }
-
-
-      /*
-       * Layout of the variables line_h1, line_h2, line_h3, which contain
-       * as bits the high resolution neighbour pixels of the currently coded
-       * highres pixel X:
-       *
-       *            76543210 76543210 76543210 76543210     line_h3
-       *            76543210 76543210 76543210 76543210     line_h2
-       *   76543210 76543210 7654321X 76543210              line_h1
-       *
-       * Layout of the variables line_l1, line_l2, line_l3, which contain
-       * the low resolution pixels near the currently coded pixel as bits.
-       * The lowres pixel in which the currently coded highres pixel is
-       * located is marked as Y:
-       *
-       *            76543210 76543210 76543210 76543210     line_l3
-       *            76543210 7654321Y 76543210 76543210     line_l2
-       *            76543210 76543210 76543210 76543210     line_l1
-       */
-      
-
-      line_h1 = line_h2 = line_h3 = line_l1 = line_l2 = line_l3 = 0;
-      if (i > 0 || !reset) line_h2 = (long)*(hp - hbpl) << 8;
-      if (i > 1 || !reset) {
-	line_h3 = (long)*(hp - hbpl - hbpl) << 8;
-	line_l3 = (long)*(lp2 - lbpl) << 8;
-      }
-      line_l2 = (long)*lp2 << 8;
-      line_l1 = (long)*lp1 << 8;
-      
-      /* encode line */
-      for (j = 0; j < hx; lp1++, lp2++) {
-	if ((j >> 1) < lbpl * 8 - 8) {
-	  if (i > 1 || !reset)
-	    line_l3 |= *(lp2 - lbpl + 1);
-	  line_l2 |= *(lp2 + 1);
-	  line_l1 |= *(lp1 + 1);
-	}
-	do { /* ... while (j & 15 && j < hx) */
-
-	  assert(hp - (s->lhp[s->highres[plane]][plane] +
-		       (stripe * hl + i) * hbpl)
-		 == (ptrdiff_t) j >> 3);
-
-	  assert(lp2 - (s->lhp[1-s->highres[plane]][plane] +
-			(stripe * ll + (i>>1)) * lbpl)
-		 == (ptrdiff_t) j >> 4);
-
-	  line_h1 |= *hp;
-	  if (j < hbpl * 8 - 8) {
-	    if (i > 0 || !reset) {
-	      line_h2 |= *(hp - hbpl + 1);
-	      if (i > 1 || !reset)
-		line_h3 |= *(hp - hbpl - hbpl + 1);
-	    }
-	  }
-	  do { /* ... while (j & 7 && j < hx) */
-	    line_l1 <<= 1;  line_l2 <<= 1;  line_l3 <<= 1;
-	    if (ltp && s->tp[j >> 1] < 2) {
-	      /* pixel are typical and have not to be encoded */
-	      line_h1 <<= 2;  line_h2 <<= 2;  line_h3 <<= 2;
-#ifdef DEBUG
-	      do {
-		++tp_pixels;
-	      } while (++j & 1 && j < hx);
-#else
-	      j += 2;
-#endif
-	    } else
-	      do { /* ... while (++j & 1 && j < hx) */
-		line_h1 <<= 1;  line_h2 <<= 1;  line_h3 <<= 1;
-
-		/* deterministic prediction */
-		if (s->options & JBG_DPON) {
-		  if ((y & 1) == 0) {
-		    if ((j & 1) == 0) {
-		      /* phase 0 */
-		      if (s->dppriv[((line_l3 >> 16) & 0x003) |
-				    ((line_l2 >> 14) & 0x00c) |
-				    ((line_h1 >> 5)  & 0x010) |
-				    ((line_h2 >> 10) & 0x0e0)] < 2) {
-#ifdef DEBUG
-			++dp_pixels;
-#endif
-			continue;
-		      }
-		    } else {
-		      /* phase 1 */
-		      if (s->dppriv[(((line_l3 >> 16) & 0x003) |
-				     ((line_l2 >> 14) & 0x00c) |
-				     ((line_h1 >> 5)  & 0x030) |
-				     ((line_h2 >> 10) & 0x1c0)) + 256] < 2) {
-#ifdef DEBUG
-			++dp_pixels;
-#endif
-			continue;
-		      }
-		    }
-		  } else {
-		    if ((j & 1) == 0) {
-		      /* phase 2 */
-		      if (s->dppriv[(((line_l3 >> 16) & 0x003) |
-				     ((line_l2 >> 14) & 0x00c) |
-				     ((line_h1 >> 5)  & 0x010) |
-				     ((line_h2 >> 10) & 0x0e0) |
-				     ((line_h3 >> 7) & 0x700)) + 768] < 2) {
-#ifdef DEBUG
-			++dp_pixels;
-#endif
-			continue;
-		      }
-		    } else {
-		      /* phase 3 */
-		      if (s->dppriv[(((line_l3 >> 16) & 0x003) |
-				     ((line_l2 >> 14) & 0x00c) |
-				     ((line_h1 >> 5)  & 0x030) |
-				     ((line_h2 >> 10) & 0x1c0) |
-				     ((line_h3 >> 7)  & 0xe00)) + 2816] < 2) {
-#ifdef DEBUG
-			++dp_pixels;
-#endif
-			continue;
-		      }
-		    }	
-		  }	
-		}
-
-		/* determine context */
-		if (s->tx[plane]) {
-		  if ((unsigned) s->tx[plane] > j)
-		    a = 0;
-		  else {
-		    o = (j - s->tx[plane]) - (j & ~7L);
-		    a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		    a <<= 4;
-		  }
-		  assert(s->tx[plane] > 23 ||
-			 a == ((line_h1 >> (4 + s->tx[plane])) & 0x010));
-		  cx = (((line_h1 >> 9)  & 0x003) | a |
-			((line_h2 >> 13) & 0x00c) |
-			((line_h3 >> 11) & 0x020));
-		} else
-		  cx = (((line_h1 >> 9)  & 0x003) |
-			((line_h2 >> 13) & 0x01c) |
-			((line_h3 >> 11) & 0x020));
-		if (j & 1)
-		  cx |= (((line_l2 >> 9)  & 0x0c0) |
-			 ((line_l1 >> 7)  & 0x300)) | (1UL << 10);
-		else
-		  cx |= (((line_l2 >> 10) & 0x0c0) |
-			 ((line_l1 >> 8)  & 0x300));
-		cx |= (y & 1) << 11;
-
-		arith_encode(se, cx, (line_h1 >> 8) & 1);
-#ifdef DEBUG
-		encoded_pixels++;
-#endif
-		
-		/* statistics for adaptive template changes */
-		if (!at_determined && j >= s->mx) {
-		  c[0] += !(((line_h2 >> 6) ^ line_h1) & 0x100);
-		  for (t = 3; t <= s->mx; t++)
-		    c[t] += !(((line_h1 >> t) ^ line_h1) & 0x100);
-		  ++c_all;
-		}
-		
-	      } while (++j & 1 && j < hx);
-	  } while (j & 7 && j < hx);
-	  hp++;
-	} while (j & 15 && j < hx);
-      } /* for (j = ...) */
-
-      /* low resolution pixels are used twice */
-      if ((i & 1) == 0) {
-	lp1 -= lbpl;
-	lp2 -= lbpl;
-      }
-      
-    } /* for (i = ...) */
-  }
-  
-  arith_encode_flush(se);
-  jbg_buf_remove_zeros(s->sde[stripe][layer][plane]);
-  jbg_buf_write(MARKER_ESC, s->sde[stripe][layer][plane]);
-  jbg_buf_write((s->options & JBG_SDRST) ? MARKER_SDRST : MARKER_SDNORM,
-		s->sde[stripe][layer][plane]);
-  if (s->options & JBG_SDRST)
-    s->tx[plane] = 0;
-
-  /* add ATMOVE */
-  if (new_tx != -1) {
-    if (s->options & JBG_DELAY_AT) {
-      /* ATMOVE will become active at the first line of the next stripe */
-      s->tx[plane] = new_tx;
-      jbg_buf_write(MARKER_ESC, s->sde[stripe][layer][plane]);
-      jbg_buf_write(MARKER_ATMOVE, s->sde[stripe][layer][plane]);
-      jbg_buf_write(0, s->sde[stripe][layer][plane]);
-      jbg_buf_write(0, s->sde[stripe][layer][plane]);
-      jbg_buf_write(0, s->sde[stripe][layer][plane]);
-      jbg_buf_write(0, s->sde[stripe][layer][plane]);
-      jbg_buf_write(s->tx[plane], s->sde[stripe][layer][plane]);
-      jbg_buf_write(0, s->sde[stripe][layer][plane]);
-    } else {
-      /* ATMOVE has already become active during this stripe
-       * => we have to prefix the SDE data with an ATMOVE marker */
-      new_jbg_buf = jbg_buf_init(&s->free_list);
-      jbg_buf_write(MARKER_ESC, new_jbg_buf);
-      jbg_buf_write(MARKER_ATMOVE, new_jbg_buf);
-      jbg_buf_write((new_tx_line >> 24) & 0xff, new_jbg_buf);
-      jbg_buf_write((new_tx_line >> 16) & 0xff, new_jbg_buf);
-      jbg_buf_write((new_tx_line >> 8) & 0xff, new_jbg_buf);
-      jbg_buf_write(new_tx_line & 0xff, new_jbg_buf);
-      jbg_buf_write(new_tx, new_jbg_buf);
-      jbg_buf_write(0, new_jbg_buf);
-      jbg_buf_prefix(new_jbg_buf, &s->sde[stripe][layer][plane]);
-    }
-  }
-
-#if 0
-  if (stripe == s->stripes - 1)
-    fprintf(stderr, "tp_lines = %ld, tp_exceptions = %ld, tp_pixels = %ld, "
-	    "dp_pixels = %ld, encoded_pixels = %ld\n",
-	    tp_lines, tp_exceptions, tp_pixels, dp_pixels, encoded_pixels);
-#endif
-
-  return;
-}
-
-
-/*
- * Create the next lower resolution version of an image
- */
-static void resolution_reduction(struct jbg_enc_state *s, int plane,
-				 int higher_layer)
-{
-  unsigned long hl, ll, hx, hy, lx, ly, hbpl, lbpl;
-  unsigned char *hp1, *hp2, *hp3, *lp;
-  unsigned long line_h1, line_h2, line_h3, line_l2;
-  unsigned long y;  /* current line number in lowres image */
-  unsigned long i;  /* current line number within lowres stripe */
-  unsigned long j;  /* current column number in lowres image */
-  int pix, k, l;
-
-  /* number of lines per stripe in highres image */
-  hl = s->l0 << higher_layer;
-  /* number of lines per stripe in lowres image */
-  ll = hl >> 1;
-  /* number of pixels in highres image */
-  hx = jbg_ceil_half(s->xd, s->d - higher_layer);
-  hy = jbg_ceil_half(s->yd, s->d - higher_layer);
-  /* number of pixels in lowres image */
-  lx = jbg_ceil_half(hx, 1);
-  ly = jbg_ceil_half(hy, 1);
-  /* bytes per line in highres and lowres image */
-  hbpl = jbg_ceil_half(hx, 3);
-  lbpl = jbg_ceil_half(lx, 3);
-  /* pointers to first image bytes */
-  hp2 = s->lhp[s->highres[plane]][plane];
-  hp1 = hp2 + hbpl;
-  hp3 = hp2 - hbpl;
-  lp = s->lhp[1 - s->highres[plane]][plane];
-  
-#ifdef DEBUG
-  fprintf(stderr, "resolution_reduction: plane = %d, higher_layer = %d\n",
-	  plane, higher_layer);
-#endif
-
-  /*
-   * Layout of the variables line_h1, line_h2, line_h3, which contain
-   * as bits the high resolution neighbour pixels of the currently coded
-   * lowres pixel /\:
-   *              \/
-   *
-   *   76543210 76543210 76543210 76543210     line_h3
-   *   76543210 76543210 765432/\ 76543210     line_h2
-   *   76543210 76543210 765432\/ 76543210     line_h1
-   *
-   * Layout of the variable line_l2, which contains the low resolution
-   * pixels near the currently coded pixel as bits. The lowres pixel
-   * which is currently coded is marked as X:
-   *
-   *   76543210 76543210 76543210 76543210     line_l2
-   *                            X
-   */
-
-  for (y = 0; y < ly;) {
-    for (i = 0; i < ll && y < ly; i++, y++) {
-      if (2*y + 1 >= hy)
-	hp1 = hp2;
-      pix = 0;
-      line_h1 = line_h2 = line_h3 = line_l2 = 0;
-      for (j = 0; j < lbpl * 8; j += 8) {
-	*lp = 0;
-	if (i > 0 || (y > 0 && !(s->options & JBG_SDRST)))
-	  line_l2 |= *(lp-lbpl);
-	for (k = 0; k < 8 && j + k < lx; k += 4) {
-	  if (((j + k) >> 2) < hbpl) {
-	    if (i > 0 || (y > 0 && !(s->options & JBG_SDRST)))
-	      line_h3 |= *hp3;
-	    ++hp3;
-	    line_h2 |= *(hp2++);
-	    line_h1 |= *(hp1++);
-	  }
-	  for (l = 0; l < 4 && j + k + l < lx; l++) {
-	    line_h3 <<= 2;
-	    line_h2 <<= 2;
-	    line_h1 <<= 2;
-	    line_l2 <<= 1;
-	    pix = s->res_tab[((line_h1 >> 8) & 0x007) |
-			     ((line_h2 >> 5) & 0x038) |
-			     ((line_h3 >> 2) & 0x1c0) |
-			     (pix << 9) | ((line_l2 << 2) & 0xc00)];
-	    *lp = (*lp << 1) | pix;
-	  }
-	}
-	++lp;
-      }
-      *(lp - 1) <<= lbpl * 8 - lx;
-      hp1 += hbpl;
-      hp2 += hbpl;
-      hp3 += hbpl;
-    }
-  }
-
-#ifdef DEBUG
-  {
-    FILE *f;
-    char fn[50];
-    
-    sprintf(fn, "dbg_d=%02d.pbm", higher_layer - 1);
-    f = fopen(fn, "wb");
-    fprintf(f, "P4\n%lu %lu\n", lx, ly);
-    fwrite(s->lhp[1 - s->highres[plane]][plane], 1, lbpl * ly, f);
-    fclose(f);
-  }
-#endif
-
-  return;
-}
-
-
-/* 
- * This function is called inside the three loops of jbg_enc_out() in
- * order to write the next SDE. It has first to generate the required
- * SDE and all SDEs which have to be encoded before this SDE can be
- * created. The problem here is that if we want to output a lower
- * resolution layer, we have to apply the resolution reduction
- * algorithm first to get it. As we try to safe as much memory as
- * possible, the resolution reduction will overwrite previous higher
- * resolution bitmaps. Consequently, we have to encode and buffer SDEs
- * which depend on higher resolution layers before we can start the
- * resolution reduction. All the logic about which SDE has to be
- * encoded before resolution reduction is allowed is handled
- * here. This approach may be a bit more complex than alternative ways
- * of doing it, but it minimizes the amount of temporary memory used.
- */
-static void output_sde(struct jbg_enc_state *s,
-		       unsigned long stripe, int layer, int plane)
-{
-  int lfcl;     /* lowest fully coded layer */
-  long i;
-  unsigned long u;
-  
-  assert(s->sde[stripe][layer][plane] != SDE_DONE);
-
-  if (s->sde[stripe][layer][plane] != SDE_TODO) {
-#ifdef DEBUG
-    fprintf(stderr, "writing SDE: s/d/p = %2lu/%2d/%2d\n",
-	    stripe, layer, plane);
-#endif
-    jbg_buf_output(&s->sde[stripe][layer][plane], s->data_out, s->file);
-    s->sde[stripe][layer][plane] = SDE_DONE;
-    return;
-  }
-
-  /* Determine the smallest resolution layer in this plane for which
-   * not yet all stripes have been encoded into SDEs. This layer will
-   * have to be completely coded, before we can apply the next
-   * resolution reduction step. */
-  lfcl = 0;
-  for (i = s->d; i >= 0; i--)
-    if (s->sde[s->stripes - 1][i][plane] == SDE_TODO) {
-      lfcl = i + 1;
-      break;
-    }
-  if (lfcl > s->d && s->d > 0 && stripe == 0) {
-    /* perform the first resolution reduction */
-    resolution_reduction(s, plane, s->d);
-  }
-  /* In case HITOLO is not used, we have to encode and store the higher
-   * resolution layers first, although we do not need them right now. */
-  while (lfcl - 1 > layer) {
-    for (u = 0; u < s->stripes; u++)
-      encode_sde(s, u, lfcl - 1, plane);
-    --lfcl;
-    s->highres[plane] ^= 1;
-    if (lfcl > 1)
-      resolution_reduction(s, plane, lfcl - 1);
-  }
-  
-  encode_sde(s, stripe, layer, plane);
-
-#ifdef DEBUG
-  fprintf(stderr, "writing SDE: s/d/p = %2lu/%2d/%2d\n", stripe, layer, plane);
-#endif
-  jbg_buf_output(&s->sde[stripe][layer][plane], s->data_out, s->file);
-  s->sde[stripe][layer][plane] = SDE_DONE;
-  
-  if (stripe == s->stripes - 1 && layer > 0 &&
-      s->sde[0][layer-1][plane] == SDE_TODO) {
-    s->highres[plane] ^= 1;
-    if (layer > 1)
-      resolution_reduction(s, plane, layer - 1);
-  }
-  
-  return;
-}
-
-
-/*
- * Convert the table which controls the deterministic prediction
- * process from the internal format into the representation required
- * for the 1728 byte long DPTABLE element of a BIH.
- *
- * The bit order of the DPTABLE format (see also ITU-T T.82 figure 13) is
- *
- * high res:   4  5  6     low res:  0  1
- *             7  8  9               2  3
- *            10 11 12
- *
- * were 4 table entries are packed into one byte, while we here use
- * internally an unpacked 6912 byte long table indexed by the following
- * bit order:
- *
- * high res:   7  6  5     high res:   8  7  6     low res:  1  0
- * (phase 0)   4  .  .     (phase 1)   5  4  .               3  2
- *             .  .  .                 .  .  .
- *
- * high res:  10  9  8     high res:  11 10  9
- * (phase 2)   7  6  5     (phase 3)   8  7  6
- *             4  .  .                 5  4  .
- */
-void jbg_int2dppriv(unsigned char *dptable, const char *internal)
-{
-  int i, j, k;
-  int trans0[ 8] = { 1, 0, 3, 2, 7, 6, 5, 4 };
-  int trans1[ 9] = { 1, 0, 3, 2, 8, 7, 6, 5, 4 };
-  int trans2[11] = { 1, 0, 3, 2, 10, 9, 8, 7, 6, 5, 4 };
-  int trans3[12] = { 1, 0, 3, 2, 11, 10, 9, 8, 7, 6, 5, 4 };
-  
-  for (i = 0; i < 1728; dptable[i++] = 0);
-
-#define FILL_TABLE1(offset, len, trans) \
-  for (i = 0; i < len; i++) { \
-    k = 0; \
-    for (j = 0; j < 8; j++) \
-      k |= ((i >> j) & 1) << trans[j]; \
-    dptable[(i + offset) >> 2] |= \
-      (internal[k + offset] & 3) << ((3 - (i&3)) << 1); \
-  }
-
-  FILL_TABLE1(   0,  256, trans0);
-  FILL_TABLE1( 256,  512, trans1);
-  FILL_TABLE1( 768, 2048, trans2);
-  FILL_TABLE1(2816, 4096, trans3);
-
-  return;
-}
-
-
-/*
- * Convert the table which controls the deterministic prediction
- * process from the 1728 byte long DPTABLE format into the 6912 byte long
- * internal format.
- */
-void jbg_dppriv2int(char *internal, const unsigned char *dptable)
-{
-  int i, j, k;
-  int trans0[ 8] = { 1, 0, 3, 2, 7, 6, 5, 4 };
-  int trans1[ 9] = { 1, 0, 3, 2, 8, 7, 6, 5, 4 };
-  int trans2[11] = { 1, 0, 3, 2, 10, 9, 8, 7, 6, 5, 4 };
-  int trans3[12] = { 1, 0, 3, 2, 11, 10, 9, 8, 7, 6, 5, 4 };
-  
-#define FILL_TABLE2(offset, len, trans) \
-  for (i = 0; i < len; i++) { \
-    k = 0; \
-    for (j = 0; j < 8; j++) \
-      k |= ((i >> j) & 1) << trans[j]; \
-    internal[k + offset] = \
-      (dptable[(i + offset) >> 2] >> ((3 - (i & 3)) << 1)) & 3; \
-  }
-
-  FILL_TABLE2(   0,  256, trans0);
-  FILL_TABLE2( 256,  512, trans1);
-  FILL_TABLE2( 768, 2048, trans2);
-  FILL_TABLE2(2816, 4096, trans3);
-
-  return;
-}
-
-
-/*
- * Encode one full BIE and pass the generated data to the specified
- * call-back function
- */
-void jbg_enc_out(struct jbg_enc_state *s)
-{
-  unsigned long bpl;
-  unsigned char buf[20];
-  unsigned long xd, yd, y;
-  long ii[3], is[3], ie[3];    /* generic variables for the 3 nested loops */ 
-  unsigned long stripe;
-  int layer, plane;
-  int order;
-  unsigned char dpbuf[1728];
-
-  /* some sanity checks */
-  s->order &= JBG_HITOLO | JBG_SEQ | JBG_ILEAVE | JBG_SMID;
-  order = s->order & (JBG_SEQ | JBG_ILEAVE | JBG_SMID);
-  if (iindex[order][0] < 0)
-    s->order = order = JBG_SMID | JBG_ILEAVE;
-  if (s->options & JBG_DPON && s->dppriv != jbg_dptable)
-    s->options |= JBG_DPPRIV;
-  if (s->mx > MX_MAX)
-    s->mx = MX_MAX;
-  s->my = 0;
-  if (s->mx && s->mx < ((s->options & JBG_LRLTWO) ? 5U : 3U))
-    s->mx = 0;
-  if (s->d > 255 || s->d < 0 || s->dh > s->d || s->dh < 0 ||
-      s->dl < 0 || s->dl > s->dh || s->planes < 0 || s->planes > 255)
-    return;
-  /* prevent uint32 overflow: s->l0 * 2 ^ s->d < 2 ^ 32 */
-  if (s->d > 31 || (s->d != 0 && s->l0 >= (1UL << (32 - s->d))))
-    return;
-  if (s->yd1 < s->yd)
-    s->yd1 = s->yd;
-  if (s->yd1 > s->yd)
-    s->options |= JBG_VLENGTH;
-
-  /* ensure correct zero padding of bitmap at the final byte of each line */
-  if (s->xd & 7) {
-    bpl = jbg_ceil_half(s->xd, 3);     /* bytes per line */
-    for (plane = 0; plane < s->planes; plane++)
-      for (y = 0; y < s->yd; y++)
-	s->lhp[0][plane][y * bpl + bpl - 1] &= ~((1 << (8 - (s->xd & 7))) - 1);
-  }
-
-  /* prepare BIH */
-  buf[0] = s->dl;
-  buf[1] = s->dh;
-  buf[2] = s->planes;
-  buf[3] = 0;
-  xd = jbg_ceil_half(s->xd, s->d - s->dh);
-  yd = jbg_ceil_half(s->yd1, s->d - s->dh);
-  buf[4] = xd >> 24;
-  buf[5] = (xd >> 16) & 0xff;
-  buf[6] = (xd >> 8) & 0xff;
-  buf[7] = xd & 0xff;
-  buf[8] = yd >> 24;
-  buf[9] = (yd >> 16) & 0xff;
-  buf[10] = (yd >> 8) & 0xff;
-  buf[11] = yd & 0xff;
-  buf[12] = s->l0 >> 24;
-  buf[13] = (s->l0 >> 16) & 0xff;
-  buf[14] = (s->l0 >> 8) & 0xff;
-  buf[15] = s->l0 & 0xff;
-  buf[16] = s->mx;
-  buf[17] = s->my;
-  buf[18] = s->order;
-  buf[19] = s->options & 0x7f;
-
-#if 0
-  /* sanitize L0 (if it was set to 0xffffffff for T.85-style NEWLEN tests) */
-  if (s->l0 > (s->yd >> s->d))
-    s->l0 = s->yd >> s->d;
-#endif
-
-  /* calculate number of stripes that will be required */
-  s->stripes = jbg_stripes(s->l0, s->yd, s->d);
-
-  /* allocate buffers for SDE pointers */
-  if (s->sde == NULL) {
-    s->sde = (struct jbg_buf ****)
-      checked_malloc(s->stripes, sizeof(struct jbg_buf ***));
-    for (stripe = 0; stripe < s->stripes; stripe++) {
-      s->sde[stripe] = (struct jbg_buf ***)
-	checked_malloc(s->d + 1, sizeof(struct jbg_buf **));
-      for (layer = 0; layer < s->d + 1; layer++) {
-	s->sde[stripe][layer] = (struct jbg_buf **)
-	  checked_malloc(s->planes, sizeof(struct jbg_buf *));
-	for (plane = 0; plane < s->planes; plane++)
-	  s->sde[stripe][layer][plane] = SDE_TODO;
-      }
-    }
-  }
-
-  /* output BIH */
-  s->data_out(buf, 20, s->file);
-  if ((s->options & (JBG_DPON | JBG_DPPRIV | JBG_DPLAST)) ==
-      (JBG_DPON | JBG_DPPRIV)) {
-    /* write private table */
-    jbg_int2dppriv(dpbuf, s->dppriv);
-    s->data_out(dpbuf, 1728, s->file);
-  }
-
-#if 0
-  /*
-   * Encode everything first. This is a simple-minded alternative to
-   * all the tricky on-demand encoding logic in output_sde() for
-   * debugging purposes.
-   */
-  for (layer = s->dh; layer >= s->dl; layer--) {
-    for (plane = 0; plane < s->planes; plane++) {
-      if (layer > 0)
-	resolution_reduction(s, plane, layer);
-      for (stripe = 0; stripe < s->stripes; stripe++)
-	encode_sde(s, stripe, layer, plane);
-      s->highres[plane] ^= 1;
-    }
-  }
-#endif
-
-  /*
-   * Generic loops over all SDEs. Which loop represents layer, plane and
-   * stripe depends on the option flags.
-   */
-
-  /* start and end value for each loop */
-  is[iindex[order][STRIPE]] = 0;
-  ie[iindex[order][STRIPE]] = s->stripes - 1;
-  is[iindex[order][LAYER]] = s->dl;
-  ie[iindex[order][LAYER]] = s->dh;
-  is[iindex[order][PLANE]] = 0;
-  ie[iindex[order][PLANE]] = s->planes - 1;
-
-  for (ii[0] = is[0]; ii[0] <= ie[0]; ii[0]++)
-    for (ii[1] = is[1]; ii[1] <= ie[1]; ii[1]++)
-      for (ii[2] = is[2]; ii[2] <= ie[2]; ii[2]++) {
-	
-	stripe = ii[iindex[order][STRIPE]];
-	if (s->order & JBG_HITOLO)
-	  layer = s->dh - (ii[iindex[order][LAYER]] - s->dl);
-	else
-	  layer = ii[iindex[order][LAYER]];
-	plane = ii[iindex[order][PLANE]];
-
-	/* output comment marker segment if there is any pending */
-	if (s->comment) {
-	  buf[0] = MARKER_ESC;
-	  buf[1] = MARKER_COMMENT;
-	  buf[2] = s->comment_len >> 24;
-	  buf[3] = (s->comment_len >> 16) & 0xff;
-	  buf[4] = (s->comment_len >> 8) & 0xff;
-	  buf[5] = s->comment_len & 0xff;
-	  s->data_out(buf, 6, s->file);
-	  s->data_out(s->comment, s->comment_len, s->file);
-	  s->comment = NULL;
-	}
-
-	output_sde(s, stripe, layer, plane);
-
-	/*
-	 * When we generate a NEWLEN test case (s->yd1 > s->yd), output
-	 * NEWLEN after last stripe if we have only a single
-	 * resolution layer or plane (see ITU-T T.85 profile), otherwise
-	 * output NEWLEN before last stripe.
-	 */
-	if (s->yd1 > s->yd &&
-	    (stripe == s->stripes - 1 ||
-	     (stripe == s->stripes - 2 && 
-	      (s->dl != s->dh || s->planes > 1)))) {
-	  s->yd1 = s->yd;
-	  yd = jbg_ceil_half(s->yd, s->d - s->dh);
-	  buf[0] = MARKER_ESC;
-	  buf[1] = MARKER_NEWLEN;
-	  buf[2] = yd >> 24;
-	  buf[3] = (yd >> 16) & 0xff;
-	  buf[4] = (yd >> 8) & 0xff;
-	  buf[5] = yd & 0xff;
-	  s->data_out(buf, 6, s->file);
-#ifdef DEBUG
-	  fprintf(stderr, "NEWLEN: yd=%lu\n", yd);
-#endif
-	  if (stripe == s->stripes - 1) {
-	    buf[1] = MARKER_SDNORM;
-	    s->data_out(buf, 2, s->file);
-	  }
-	}
-
-      }
-
-  return;
-}
-
-
-void jbg_enc_free(struct jbg_enc_state *s)
-{
-  unsigned long stripe;
-  int layer, plane;
-
-#ifdef DEBUG
-  fprintf(stderr, "jbg_enc_free(%p)\n", (void *) s);
-#endif
-
-  /* clear buffers for SDEs */
-  if (s->sde) {
-    for (stripe = 0; stripe < s->stripes; stripe++) {
-      for (layer = 0; layer < s->d + 1; layer++) {
-	for (plane = 0; plane < s->planes; plane++)
-	  if (s->sde[stripe][layer][plane] != SDE_DONE &&
-	      s->sde[stripe][layer][plane] != SDE_TODO)
-	    jbg_buf_free(&s->sde[stripe][layer][plane]);
-	checked_free(s->sde[stripe][layer]);
-      }
-      checked_free(s->sde[stripe]);
-    }
-    checked_free(s->sde);
-  }
-
-  /* clear free_list */
-  jbg_buf_free(&s->free_list);
-
-  /* clear memory for arithmetic encoder states */
-  checked_free(s->s);
-
-  /* clear memory for differential-layer typical prediction buffer */
-  checked_free(s->tp);
-
-  /* clear memory for adaptive template pixel offsets */
-  checked_free(s->tx);
-
-  /* clear lowres image buffers */
-  if (s->lhp[1]) {
-    for (plane = 0; plane < s->planes; plane++)
-      checked_free(s->lhp[1][plane]);
-    checked_free(s->lhp[1]);
-  }
-  
-  /* clear buffer for index of highres image in lhp */
-  checked_free(s->highres);
-  
-  return;
-}
-
-
-/*
- * Convert the error codes used by jbg_dec_in() into an English ASCII string
- */
-const char *jbg_strerror(int errnum)
-{
-  errnum >>= 4;
-  if (errnum < 0 || (unsigned) errnum >= sizeof(errmsg)/sizeof(errmsg[0]))
-    return "Unknown error code passed to jbg_strerror()";
-
-  return errmsg[errnum];
-}
-
-
-/*
- * The constructor for a decoder 
- */
-void jbg_dec_init(struct jbg_dec_state *s)
-{
-  s->order = 0;
-  s->d = -1;
-  s->bie_len = 0;
-  s->buf_len = 0;
-  s->dppriv = NULL;
-  s->xmax = 4294967295UL;
-  s->ymax = 4294967295UL;
-  s->dmax = 256;
-  s->s = NULL;
-
-  return;
-}
-
-
-/*
- * Specify a maximum image size for the decoder. If the JBIG file has
- * the order bit ILEAVE, but not the bit SEQ set, then the decoder
- * will abort to decode after the image has reached the maximal
- * resolution layer which is still not wider than xmax or higher than
- * ymax.
- */
-void jbg_dec_maxsize(struct jbg_dec_state *s, unsigned long xmax,
-		     unsigned long ymax)
-{
-  if (xmax > 0) s->xmax = xmax;
-  if (ymax > 0) s->ymax = ymax;
-
-  return;
-}
-
-
-/*
- * Decode the new len PSDC bytes to which data points and add them to
- * the current stripe. Return the number of bytes which have actually
- * been read (this will be less than len if a marker segment was 
- * part of the data or if the final byte was 0xff were this code
- * can not determine, whether we have a marker segment.
- */
-static size_t decode_pscd(struct jbg_dec_state *s, unsigned char *data,
-			  size_t len)
-{
-  unsigned long stripe;
-  unsigned int layer, plane;
-  unsigned long hl, ll, y, hx, hy, lx, ly, hbpl, lbpl;
-  unsigned char *hp, *lp1, *lp2, *p1, *q1;
-  register unsigned long line_h1, line_h2, line_h3;
-  register unsigned long line_l1, line_l2, line_l3;
-  struct jbg_ardec_state *se;
-  unsigned long x;
-  long o;
-  unsigned a;
-  int n;
-  int pix, cx = 0, slntp, tx;
-
-  /* SDE loop variables */
-  stripe = s->ii[iindex[s->order & 7][STRIPE]];
-  layer = s->ii[iindex[s->order & 7][LAYER]];
-  plane = s->ii[iindex[s->order & 7][PLANE]];
-
-  /* forward data to arithmetic decoder */
-  se = s->s[plane] + layer - s->dl;
-  se->pscd_ptr = data;
-  se->pscd_end = data + len;
-  
-  /* number of lines per stripe in highres image */
-  hl = s->l0 << layer;
-  /* number of lines per stripe in lowres image */
-  ll = hl >> 1;
-  /* current line number in highres image */
-  y = stripe * hl + s->i;
-  /* number of pixels in highres image */
-  hx = jbg_ceil_half(s->xd, s->d - layer);
-  hy = jbg_ceil_half(s->yd, s->d - layer);
-  /* number of pixels in lowres image */
-  lx = jbg_ceil_half(hx, 1);
-  ly = jbg_ceil_half(hy, 1);
-  /* bytes per line in highres and lowres image */
-  hbpl = jbg_ceil_half(hx, 3);
-  lbpl = jbg_ceil_half(lx, 3);
-  /* pointer to highres and lowres image bytes */
-  hp  = s->lhp[ layer    & 1][plane] + (stripe * hl + s->i) * hbpl +
-    (s->x >> 3);
-  lp2 = s->lhp[(layer-1) & 1][plane] + (stripe * ll + (s->i >> 1)) * lbpl +
-    (s->x >> 4);
-  lp1 = lp2 + lbpl;
-
-  /* restore a few local variables */
-  line_h1 = s->line_h1;
-  line_h2 = s->line_h2;
-  line_h3 = s->line_h3;
-  line_l1 = s->line_l1;
-  line_l2 = s->line_l2;
-  line_l3 = s->line_l3;
-  x = s->x;
-
-#ifdef DEBUG
-  if (s->x == 0 && s->i == 0 && s->pseudo)
-    fprintf(stderr, "decode_pscd(%p, %p, %ld): s/d/p = %2lu/%2u/%2u\n",
-	    (void *) s, (void *) data, (long) len, stripe, layer, plane);
-#endif
-
-  if (s->x == 0 && s->i == 0 &&
-      (stripe == 0 || s->reset[plane][layer - s->dl]) && s->pseudo) {
-    s->tx[plane][layer - s->dl] = s->ty[plane][layer - s->dl] = 0;
-    s->lntp[plane][layer - s->dl] = 1;
-  }
-
-  if (layer == 0) {
-
-    /*
-     *  Decode lowest resolution layer
-     */
-
-    for (; s->i < hl && y < hy; s->i++, y++) {
-
-      /* adaptive template changes */
-      if (x == 0 && s->pseudo)
-	for (n = 0; n < s->at_moves; n++)
-	  if (s->at_line[n] == s->i) {
-	    s->tx[plane][layer - s->dl] = s->at_tx[n];
-	    s->ty[plane][layer - s->dl] = s->at_ty[n];
-#ifdef DEBUG
-	    fprintf(stderr, "ATMOVE: line=%lu, tx=%d, ty=%d.\n", s->i,
-		    s->tx[plane][layer - s->dl], s->ty[plane][layer - s->dl]);
-#endif
-	  }
-      tx = s->tx[plane][layer - s->dl];
-      assert(tx >= 0); /* i.e., tx can safely be cast to unsigned */
-
-      /* typical prediction */
-      if (s->options & JBG_TPBON && s->pseudo) {
-	slntp = arith_decode(se, (s->options & JBG_LRLTWO) ? TPB2CX : TPB3CX);
-	if (slntp < 0)
-	  goto leave;
-	s->lntp[plane][layer - s->dl] =
-	  !(slntp ^ s->lntp[plane][layer - s->dl]);
-	if (!s->lntp[plane][layer - s->dl]) {
-	  /* this line is 'typical' (i.e. identical to the previous one) */
-	  p1 = hp;
-	  if (s->i == 0 && (stripe == 0 || s->reset[plane][layer - s->dl]))
-	    while (p1 < hp + hbpl) *p1++ = 0;
-	  else {
-	    q1 = hp - hbpl;
-	    while (q1 < hp) *p1++ = *q1++;
-	  }
-	  hp += hbpl;
-	  continue;
-	}
-	/* this line is 'not typical' and has to be coded completely */
-      }
-      s->pseudo = 0;
-      
-      /*
-       * Layout of the variables line_h1, line_h2, line_h3, which contain
-       * as bits the neighbour pixels of the currently decoded pixel X:
-       *
-       *                     76543210 76543210 76543210 76543210     line_h3
-       *                     76543210 76543210 76543210 76543210     line_h2
-       *   76543210 76543210 76543210 76543210 X                     line_h1
-       */
-      
-      if (x == 0) {
-	line_h1 = line_h2 = line_h3 = 0;
-	if (s->i > 0 || (y > 0 && !s->reset[plane][layer - s->dl]))
-	  line_h2 = (long)*(hp - hbpl) << 8;
-	if (s->i > 1 || (y > 1 && !s->reset[plane][layer - s->dl]))
-	  line_h3 = (long)*(hp - hbpl - hbpl) << 8;
-      }
-      
-      /*
-       * Another tiny JBIG standard bug:
-       *
-       * While implementing the line_h3 handling here, I discovered
-       * another problem with the ITU-T T.82(1993 E) specification.
-       * This might be a somewhat pathological case, however. The
-       * standard is unclear about how a decoder should behave in the
-       * following situation:
-       *
-       * Assume we are in layer 0 and all stripes are single lines
-       * (L0=1 allowed by table 9). We are now decoding the first (and
-       * only) line of the third stripe. Assume, the first stripe was
-       * terminated by SDRST and the second stripe was terminated by
-       * SDNORM. While decoding the only line of the third stripe with
-       * the three-line template, we need access to pixels from the
-       * previous two stripes. We know that the previous stripe
-       * terminated with SDNROM, so we access the pixel from the
-       * second stripe. But do we have to replace the pixels from the
-       * first stripe by background pixels, because this stripe ended
-       * with SDRST? The standard, especially clause 6.2.5 does never
-       * mention this case, so the behaviour is undefined here. My
-       * current implementation remembers only the marker used to
-       * terminate the previous stripe. In the above example, the
-       * pixels of the first stripe are accessed despite the fact that
-       * this stripe ended with SDRST. An alternative (only slightly
-       * more complicated) implementation would be to remember the end
-       * marker (SDNORM or SDRST) of the previous two stripes in a
-       * plane/layer and to act accordingly when accessing the two
-       * previous lines. What am I supposed to do here?
-       *
-       * As the standard is unclear about the correct behaviour in the
-       * situation of the above example, I strongly suggest to avoid
-       * the following situation while encoding data with JBIG:
-       *
-       *   LRLTWO = 0, L0=1 and both SDNORM and SDRST appear in layer 0.
-       *
-       * I guess that only a very few if any encoders will switch
-       * between SDNORM and SDRST, so let us hope that this ambiguity
-       * in the standard will never cause any interoperability
-       * problems.
-       *
-       * Markus Kuhn -- 1995-04-30
-       */
-
-      /* decode line */
-      while (x < hx) {
-	if ((x & 7) == 0) {
-	  if (x < hbpl * 8 - 8 &&
-	      (s->i > 0 || (y > 0 && !s->reset[plane][layer - s->dl]))) {
-	    line_h2 |= *(hp - hbpl + 1);
-	    if (s->i > 1 || (y > 1 && !s->reset[plane][layer - s->dl]))
-	      line_h3 |= *(hp - hbpl - hbpl + 1);
-	  }
-	}
-	if (s->options & JBG_LRLTWO) {
-	  /* two line template */
-	  do {
-	    if (tx) {
-	      if ((unsigned) tx > x)
-		a = 0;
-	      else if (tx < 8)
-		a = ((line_h1 >> (tx - 5)) & 0x010);
-	      else {
-		o = (x - tx) - (x & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		a <<= 4;
-	      }
-	      assert(tx > 31 ||
-		     a == ((line_h1 >> (tx - 5)) & 0x010));
-	      pix = arith_decode(se, (((line_h2 >> 9) & 0x3e0) | a |
-				      (line_h1 & 0x00f)));
-	    } else
-	      pix = arith_decode(se, (((line_h2 >> 9) & 0x3f0) |
-				      (line_h1 & 0x00f)));
-	    if (pix < 0)
-	      goto leave;
-	    line_h1 = (line_h1 << 1) | pix;
-	    line_h2 <<= 1;
-	  } while ((++x & 7) && x < hx);
-	} else {
-	  /* three line template */
-	  do {
-	    if (tx) {
-	      if ((unsigned) tx > x)
-		a = 0;
-	      else if (tx < 8)
-		a = ((line_h1 >> (tx - 3)) & 0x004);
-	      else {
-		o = (x - tx) - (x & ~7L);
-		a = (hp[o >> 3] >> (7 - (o & 7))) & 1;
-		a <<= 2;
-	      }
-	      assert(tx > 31 ||
-		     a == ((line_h1 >> (tx - 3)) & 0x004));
-	      pix = arith_decode(se, (((line_h3 >>  7) & 0x380) |
-				      ((line_h2 >> 11) & 0x078) | a |
-				      (line_h1 & 0x003)));
-	    } else
-	      pix = arith_decode(se, (((line_h3 >>  7) & 0x380) |
-				      ((line_h2 >> 11) & 0x07c) |
-				      (line_h1 & 0x003)));
-	    if (pix < 0)
-	      goto leave;
-	    
-	    line_h1 = (line_h1 << 1) | pix;
-	    line_h2 <<= 1;
-	    line_h3 <<= 1;
-	  } while ((++x & 7) && x < hx);
-	} /* if (s->options & JBG_LRLTWO) */
-	*hp++ = line_h1;
-      } /* while */
-      *(hp - 1) <<= hbpl * 8 - hx;
-      x = 0;
-      s->pseudo = 1;
-    } /* for (i = ...) */
-    
-  } else {
-
-    /*
-     *  Decode differential layer
-     */
-
-    for (; s->i < hl && y < hy; s->i++, y++) {
-
-      /* adaptive template changes */
-      if (x == 0)
-	for (n = 0; n < s->at_moves; n++)
-	  if (s->at_line[n] == s->i) {
-	    s->tx[plane][layer - s->dl] = s->at_tx[n];
-	    s->ty[plane][layer - s->dl] = s->at_ty[n];
-#ifdef DEBUG
-	    fprintf(stderr, "ATMOVE: line=%lu, tx=%d, ty=%d.\n", s->i,
-		    s->tx[plane][layer - s->dl], s->ty[plane][layer - s->dl]);
-#endif
-	  }
-      tx = s->tx[plane][layer - s->dl];
-
-      /* handle lower border of low-resolution image */
-      if ((s->i >> 1) >= ll - 1 || (y >> 1) >= ly - 1)
-	lp1 = lp2;
-
-      /* typical prediction */
-      if ((s->options & JBG_TPDON) && s->pseudo) {
-	if ((s->lntp[plane][layer - s->dl] = arith_decode(se, TPDCX)) < 0)
-	  goto leave;
-      }
-      s->pseudo = 0;
-
-      /*
-       * Layout of the variables line_h1, line_h2, line_h3, which contain
-       * as bits the high resolution neighbour pixels of the currently
-       * decoded highres pixel X:
-       *
-       *                     76543210 76543210 76543210 76543210     line_h3
-       *                     76543210 76543210 76543210 76543210     line_h2
-       *   76543210 76543210 76543210 76543210 X                     line_h1
-       *
-       * Layout of the variables line_l1, line_l2, line_l3, which contain
-       * the low resolution pixels near the currently decoded pixel as bits.
-       * The lowres pixel in which the currently coded highres pixel is
-       * located is marked as Y:
-       *
-       *                     76543210 76543210 76543210 76543210     line_l3
-       *                     76543210 76543210 Y6543210 76543210     line_l2
-       *                     76543210 76543210 76543210 76543210     line_l1
-       */
-      
-
-      if (x == 0) {
-	line_h1 = line_h2 = line_h3 = line_l1 = line_l2 = line_l3 = 0;
-	if (s->i > 0 || (y > 0 && !s->reset[plane][layer - s->dl])) {
-	  line_h2 = (long)*(hp - hbpl) << 8;
-	  if (s->i > 1 || (y > 1 && !s->reset[plane][layer - s->dl]))
-	    line_h3 = (long)*(hp - hbpl - hbpl) << 8;
-	}
-	if (s->i > 1 || (y > 1 && !s->reset[plane][layer-s->dl]))
-	  line_l3 = (long)*(lp2 - lbpl) << 8;
-	line_l2 = (long)*lp2 << 8;
-	line_l1 = (long)*lp1 << 8;
-      }
-      
-      /* decode line */
-      while (x < hx) {
-	if ((x & 15) == 0)
-	  if ((x >> 1) < lbpl * 8 - 8) {
-	    line_l1 |= *(lp1 + 1);
-	    line_l2 |= *(lp2 + 1);
-	    if (s->i > 1 || 
-		(y > 1 && !s->reset[plane][layer - s->dl]))
-	      line_l3 |= *(lp2 - lbpl + 1);
-	  }
-	do {
-
-	  assert(hp  - (s->lhp[ layer     &1][plane] + (stripe * hl + s->i)
-			* hbpl) == (ptrdiff_t) x >> 3);
-	  assert(lp2 - (s->lhp[(layer-1) &1][plane] + (stripe * ll + (s->i>>1))
-			* lbpl) == (ptrdiff_t) x >> 4);
-
-	  if ((x & 7) == 0)
-	    if (x < hbpl * 8 - 8) {
-	      if (s->i > 0 || (y > 0 && !s->reset[plane][layer - s->dl])) {
-		line_h2 |= *(hp + 1 - hbpl);
-		if (s->i > 1 || (y > 1 && !s->reset[plane][layer - s->dl]))
-		  line_h3 |= *(hp + 1 - hbpl - hbpl);
-	      }
-	    }
-	  do {
-	    if (!s->lntp[plane][layer - s->dl])
-              cx = (((line_l3 >> 14) & 0x007) |
-                    ((line_l2 >> 11) & 0x038) |
-                    ((line_l1 >> 8)  & 0x1c0));
-	    if (!s->lntp[plane][layer - s->dl] &&
-		(cx == 0x000 || cx == 0x1ff)) {
-	      /* pixels are typical and have not to be decoded */
-	      do {
-		line_h1 = (line_h1 << 1) | (cx & 1);
-	      } while ((++x & 1) && x < hx);
-	      line_h2 <<= 2;  line_h3 <<= 2;
-	    } else 
-	      do {
-		
-		/* deterministic prediction */
-		if (s->options & JBG_DPON)
-		  if ((y & 1) == 0)
-		    if ((x & 1) == 0) 
-		      /* phase 0 */
-		      pix = s->dppriv[((line_l3 >> 15) & 0x003) |
-				      ((line_l2 >> 13) & 0x00c) |
-				      ((line_h1 <<  4) & 0x010) |
-				      ((line_h2 >>  9) & 0x0e0)];
-		    else
-		      /* phase 1 */
-		      pix = s->dppriv[(((line_l3 >> 15) & 0x003) |
-				       ((line_l2 >> 13) & 0x00c) |
-				       ((line_h1 <<  4) & 0x030) |
-				       ((line_h2 >>  9) & 0x1c0)) + 256];
-		  else
-		    if ((x & 1) == 0)
-		      /* phase 2 */
-		      pix = s->dppriv[(((line_l3 >> 15) & 0x003) |
-				       ((line_l2 >> 13) & 0x00c) |
-				       ((line_h1 <<  4) & 0x010) |
-				       ((line_h2 >>  9) & 0x0e0) |
-				       ((line_h3 >>  6) & 0x700)) + 768];
-		    else
-		      /* phase 3 */
-		      pix = s->dppriv[(((line_l3 >> 15) & 0x003) |
-				       ((line_l2 >> 13) & 0x00c) |
-				       ((line_h1 <<  4) & 0x030) |
-				       ((line_h2 >>  9) & 0x1c0) |
-				       ((line_h3 >>  6) & 0xe00)) + 2816];
-		else
-		  pix = 2;
-
-		if (pix & 2) {
-		  if (tx)
-		    cx = ((line_h1         & 0x003) |
-			  (((line_h1 << 2) >> (tx - 3)) & 0x010) |
-			  ((line_h2 >> 12) & 0x00c) |
-			  ((line_h3 >> 10) & 0x020));
-		  else
-		    cx = ((line_h1         & 0x003) |
-			  ((line_h2 >> 12) & 0x01c) |
-			  ((line_h3 >> 10) & 0x020));
-		  if (x & 1)
-		    cx |= (((line_l2 >> 8) & 0x0c0) |
-			   ((line_l1 >> 6) & 0x300)) | (1UL << 10);
-		  else
-		    cx |= (((line_l2 >> 9) & 0x0c0) |
-			   ((line_l1 >> 7) & 0x300));
-		  cx |= (y & 1) << 11;
-
-		  pix = arith_decode(se, cx);
-		  if (pix < 0)
-		    goto leave;
-		}
-
-		line_h1 = (line_h1 << 1) | pix;
-		line_h2 <<= 1;
-		line_h3 <<= 1;
-		
-	      } while ((++x & 1) && x < hx);
-	    line_l1 <<= 1; line_l2 <<= 1;  line_l3 <<= 1;
-	  } while ((x & 7) && x < hx);
-	  *hp++ = line_h1;
-	} while ((x & 15) && x < hx);
-	++lp1;
-	++lp2;
-      } /* while */
-      x = 0;
-      
-      *(hp - 1) <<= hbpl * 8 - hx;
-      if ((s->i & 1) == 0) {
-	/* low resolution pixels are used twice */
-	lp1 -= lbpl;
-	lp2 -= lbpl;
-      } else
-	s->pseudo = 1;
-      
-    } /* for (i = ...) */
-    
-  }
-
- leave:
-
-  /* save a few local variables */
-  s->line_h1 = line_h1;
-  s->line_h2 = line_h2;
-  s->line_h3 = line_h3;
-  s->line_l1 = line_l1;
-  s->line_l2 = line_l2;
-  s->line_l3 = line_l3;
-  s->x = x;
-
-  return se->pscd_ptr - data;
-}
-
-
-/*
- * Provide to the decoder a new BIE fragment of len bytes starting at data.
- *
- * Unless cnt is NULL, *cnt will contain the number of actually read bytes
- * on return.
- *
- * Normal return values:
- *
- *   JBG_EAGAIN      All data bytes provided so far have been processed
- *                   (*cnt == len) but the end of the data stream has
- *                   not yet been recognized. Call the function again
- *                   with additional BIE bytes.
- *   JBG_EOK         The function has reached the end of a and
- *                   a full image has been decoded. The function can
- *                   be called again with data from the next BIE, if
- *                   there exists one, in order to get to a higher
- *                   resolution layer. The remaining len - *cnt bytes
- *                   of the previous data block will then have to passed
- *                   to this function again if len > *cnt.
- *   JBG_EOK_INTR    Parsing the BIE has been interrupted as had been
- *                   requested by a jbg_dec_maxsize() specification.
- *                   This function can be called again with the
- *                   rest of the BIE to continue the decoding process.
- *                   The remaining len - *cnt bytes of the previous
- *                   data block will then have to be passed to this
- *                   function again if len > *cnt.
- *
- * Any other return value indicates that the decoding process was
- * aborted by a serious problem and the only function you can then
- * still call is jbg_dec_free() in order to remove the mess, and
- * jbg85_strerror() to find out what to tell the user. (Looking at the
- * least significant bits of the return value will provide additional
- * information by identifying which test exactly has failed.)
- */
-int jbg_dec_in(struct jbg_dec_state *s, unsigned char *data, size_t len,
-	       size_t *cnt)
-{
-  int i, j, required_length;
-  unsigned long x, y;
-  unsigned long is[3], ie[3];
-  size_t dummy_cnt;
-
-  if (!cnt) cnt = &dummy_cnt;
-  *cnt = 0;
-  if (len < 1) return JBG_EAGAIN;
-
-  /* read in 20-byte BIH */
-  if (s->bie_len < 20) {
-    while (s->bie_len < 20 && *cnt < len)
-      s->buffer[s->bie_len++] = data[(*cnt)++];
-    if (s->bie_len < 20) 
-      return JBG_EAGAIN;
-    /* test whether this looks like a valid JBIG header at all */
-    if (s->buffer[1] < s->buffer[0])
-      return JBG_EINVAL | 1;
-    if (s->buffer[3] != 0)           return JBG_EINVAL | 2; /* padding != 0 */
-    if ((s->buffer[18] & 0xf0) != 0) return JBG_EINVAL | 3; /* padding != 0 */
-    if ((s->buffer[19] & 0x80) != 0) return JBG_EINVAL | 4; /* padding != 0 */
-    if (s->buffer[0] != s->d + 1)
-      return JBG_ENOCONT | 1;
-    s->dl = s->buffer[0];
-    s->d = s->buffer[1];
-    if (s->dl == 0)
-      s->planes = s->buffer[2];
-    else
-      if (s->planes != s->buffer[2])
-	return JBG_ENOCONT | 2;
-    x = (((long) s->buffer[ 4] << 24) | ((long) s->buffer[ 5] << 16) |
-	 ((long) s->buffer[ 6] <<  8) | (long) s->buffer[ 7]);
-    y = (((long) s->buffer[ 8] << 24) | ((long) s->buffer[ 9] << 16) |
-	 ((long) s->buffer[10] <<  8) | (long) s->buffer[11]);
-    if (s->dl != 0 && ((s->xd << (s->d - s->dl + 1)) != x &&
-		       (s->yd << (s->d - s->dl + 1)) != y))
-      return JBG_ENOCONT | 3;
-    s->xd = x;
-    s->yd = y;
-    s->l0 = (((long) s->buffer[12] << 24) | ((long) s->buffer[13] << 16) |
-	     ((long) s->buffer[14] <<  8) | (long) s->buffer[15]);
-    /* ITU-T T.85 trick not directly supported by decoder; for full
-     * T.85 compatibility with respect to all NEWLEN marker scenarios,
-     * preprocess BIE with jbg_newlen() before passing it to the decoder,
-     * or consider using the decoder found in jbig85.c instead. */
-    if (s->yd == 0xffffffff)
-      return JBG_EIMPL | 1;
-    if (!s->planes) return JBG_EINVAL | 5;
-    if (!s->xd)     return JBG_EINVAL | 6;
-    if (!s->yd)     return JBG_EINVAL | 7;
-    if (!s->l0)     return JBG_EINVAL | 8;
-    /* prevent uint32 overflow: s->l0 * 2 ^ s->d < 2 ^ 32 */
-    if (s->d > 31)
-      return JBG_EIMPL | 2;
-    if ((s->d != 0 && s->l0 >= (1UL << (32 - s->d))))
-      return JBG_EIMPL | 3;
-    s->mx = s->buffer[16];
-    if (s->mx > 127)
-      return JBG_EINVAL | 9;
-    s->my = s->buffer[17];
-#if 0
-    if (s->my > 0)
-      return JBG_EIMPL | 4;
-#endif
-    s->order = s->buffer[18];
-    if (iindex[s->order & 7][0] < 0)
-      return JBG_EINVAL | 10;
-    /* HITOLO and SEQ currently not yet implemented */
-    if (s->dl != s->d && (s->order & JBG_HITOLO || s->order & JBG_SEQ))
-      return JBG_EIMPL | 5;
-    s->options = s->buffer[19];
-
-    /* calculate number of stripes that will be required */
-    s->stripes = jbg_stripes(s->l0, s->yd, s->d);
-    
-    /* some initialization */
-    s->ii[iindex[s->order & 7][STRIPE]] = 0;
-    s->ii[iindex[s->order & 7][LAYER]] = s->dl;
-    s->ii[iindex[s->order & 7][PLANE]] = 0;
-    if (s->dl == 0) {
-      s->s      = (struct jbg_ardec_state **)
-	checked_malloc(s->planes, sizeof(struct jbg_ardec_state *));
-      s->tx     = (int **) checked_malloc(s->planes, sizeof(int *));
-      s->ty     = (int **) checked_malloc(s->planes, sizeof(int *));
-      s->reset  = (int **) checked_malloc(s->planes, sizeof(int *));
-      s->lntp   = (int **) checked_malloc(s->planes, sizeof(int *));
-      s->lhp[0] = (unsigned char **)
-	checked_malloc(s->planes, sizeof(unsigned char *));
-      s->lhp[1] = (unsigned char **)
-	checked_malloc(s->planes, sizeof(unsigned char *));
-      for (i = 0; i < s->planes; i++) {
-	s->s[i]     = (struct jbg_ardec_state *)
-	  checked_malloc(s->d - s->dl + 1, sizeof(struct jbg_ardec_state));
-	s->tx[i]    = (int *) checked_malloc(s->d - s->dl + 1, sizeof(int));
-	s->ty[i]    = (int *) checked_malloc(s->d - s->dl + 1, sizeof(int));
-	s->reset[i] = (int *) checked_malloc(s->d - s->dl + 1, sizeof(int));
-	s->lntp[i]  = (int *) checked_malloc(s->d - s->dl + 1, sizeof(int));
-	s->lhp[ s->d    & 1][i] = (unsigned char *)
-	  checked_malloc(s->yd, jbg_ceil_half(s->xd, 3));
-	s->lhp[(s->d-1) & 1][i] = (unsigned char *)
-	  checked_malloc(jbg_ceil_half(s->yd, 1), jbg_ceil_half(s->xd, 1+3));
-      }
-    } else {
-      for (i = 0; i < s->planes; i++) {
-	s->s[i]     = (struct jbg_ardec_state *)
-	  checked_realloc(s->s[i], s->d - s->dl + 1,
-			  sizeof(struct jbg_ardec_state));
-	s->tx[i]    = (int *) checked_realloc(s->tx[i],
-					      s->d - s->dl + 1, sizeof(int));
-	s->ty[i]    = (int *) checked_realloc(s->ty[i],
-					      s->d - s->dl + 1, sizeof(int));
-	s->reset[i] = (int *) checked_realloc(s->reset[i],
-					      s->d - s->dl + 1, sizeof(int));
-	s->lntp[i]  = (int *) checked_realloc(s->lntp[i],
-					      s->d - s->dl + 1, sizeof(int));
-	s->lhp[ s->d    & 1][i] = (unsigned char *)
-	  checked_realloc(s->lhp[ s->d    & 1][i],
-			  s->yd, jbg_ceil_half(s->xd, 3));
-	s->lhp[(s->d-1) & 1][i] = (unsigned char *)
-	  checked_realloc(s->lhp[(s->d-1) & 1][i],
-			  jbg_ceil_half(s->yd, 1), jbg_ceil_half(s->xd, 1+3));
-      }
-    }
-    for (i = 0; i < s->planes; i++)
-      for (j = 0; j <= s->d - s->dl; j++)
-	arith_decode_init(s->s[i] + j, 0);
-    if (s->dl == 0 || (s->options & JBG_DPON && !(s->options & JBG_DPPRIV)))
-      s->dppriv = jbg_dptable;
-    s->comment_skip = 0;
-    s->buf_len = 0;
-    s->x = 0;
-    s->i = 0;
-    s->pseudo = 1;
-    s->at_moves = 0;
-  }
-
-  /* read in DPTABLE */
-  if (s->bie_len < 20 + 1728 && 
-      (s->options & (JBG_DPON | JBG_DPPRIV | JBG_DPLAST)) ==
-      (JBG_DPON | JBG_DPPRIV)) {
-    assert(s->bie_len >= 20);
-    while (s->bie_len < 20 + 1728 && *cnt < len)
-      s->buffer[s->bie_len++ - 20] = data[(*cnt)++];
-    if (s->bie_len < 20 + 1728) 
-      return JBG_EAGAIN;
-    if (!s->dppriv || s->dppriv == jbg_dptable)
-      s->dppriv = (char *) checked_malloc(1728, sizeof(char));
-    jbg_dppriv2int(s->dppriv, s->buffer);
-  }
-
-  /*
-   * BID processing loop
-   */
-  
-  while (*cnt < len) {
-
-    /* process floating marker segments */
-
-    /* skip COMMENT contents */
-    if (s->comment_skip) {
-      if (s->comment_skip <= len - *cnt) {
-	*cnt += s->comment_skip;
-	s->comment_skip = 0;
-      } else {
-	s->comment_skip -= len - *cnt;
-	*cnt = len;
-      }
-      continue;
-    }
-
-    /* load complete marker segments into s->buffer for processing */
-    if (s->buf_len > 0) {
-      assert(s->buffer[0] == MARKER_ESC);
-      while (s->buf_len < 2 && *cnt < len)
-	s->buffer[s->buf_len++] = data[(*cnt)++];
-      if (s->buf_len < 2) continue;
-      switch (s->buffer[1]) {
-      case MARKER_COMMENT: required_length = 6; break;
-      case MARKER_ATMOVE:  required_length = 8; break;
-      case MARKER_NEWLEN:  required_length = 6; break;
-      case MARKER_ABORT:
-      case MARKER_SDNORM:
-      case MARKER_SDRST:   required_length = 2; break;
-      case MARKER_STUFF:
-	/* forward stuffed 0xff to arithmetic decoder */
-	s->buf_len = 0;
-	decode_pscd(s, s->buffer, 2);
-	continue;
-      default:
-	return JBG_EMARKER;
-      }
-      while (s->buf_len < required_length && *cnt < len)
-	s->buffer[s->buf_len++] = data[(*cnt)++];
-      if (s->buf_len < required_length) continue;
-      /* now the buffer is filled with exactly one marker segment */
-      switch (s->buffer[1]) {
-      case MARKER_COMMENT:
-	s->comment_skip =
-	  (((long) s->buffer[2] << 24) | ((long) s->buffer[3] << 16) |
-	   ((long) s->buffer[4] <<  8) | (long) s->buffer[5]);
-	break;
-      case MARKER_ATMOVE:
-	if (s->at_moves < JBG_ATMOVES_MAX) {
-	  s->at_line[s->at_moves] =
-	    (((long) s->buffer[2] << 24) | ((long) s->buffer[3] << 16) |
-	     ((long) s->buffer[4] <<  8) | (long) s->buffer[5]);
-	  s->at_tx[s->at_moves] = (signed char) s->buffer[6];
-	  s->at_ty[s->at_moves] = s->buffer[7];
-	  if (s->at_tx[s->at_moves] < - (int) s->mx ||
-	      s->at_tx[s->at_moves] >   (int) s->mx ||
-	      s->at_ty[s->at_moves] >   (int) s->my ||
-	      (s->at_ty[s->at_moves] == 0 && s->at_tx[s->at_moves] < 0))
-	    return JBG_EINVAL | 11;
-	  if (s->at_ty[s->at_moves] != 0)
-	    return JBG_EIMPL | 6;
-	  s->at_moves++;
-	} else
-	  return JBG_EIMPL | 7; /* more than JBG_ATMOVES_MAX ATMOVES */
-	break;
-      case MARKER_NEWLEN:
-	y = (((long) s->buffer[2] << 24) | ((long) s->buffer[3] << 16) |
-	     ((long) s->buffer[4] <<  8) | (long) s->buffer[5]);
-	if (y > s->yd)                   return JBG_EINVAL | 12;
-	if (!(s->options & JBG_VLENGTH)) return JBG_EINVAL | 13;
-	s->yd = y;
-	/* calculate again number of stripes that will be required */
-	s->stripes = jbg_stripes(s->l0, s->yd, s->d);
-	break;
-      case MARKER_ABORT:
-	return JBG_EABORT;
-	
-      case MARKER_SDNORM:
-      case MARKER_SDRST:
-	/* decode final pixels based on trailing zero bytes */
-	decode_pscd(s, s->buffer, 2);
-
-	arith_decode_init(s->s[s->ii[iindex[s->order & 7][PLANE]]] + 
-			  s->ii[iindex[s->order & 7][LAYER]] - s->dl,
-			  s->ii[iindex[s->order & 7][STRIPE]] != s->stripes - 1
-			  && s->buffer[1] != MARKER_SDRST);
-	
-	s->reset[s->ii[iindex[s->order & 7][PLANE]]]
-	  [s->ii[iindex[s->order & 7][LAYER]] - s->dl] =
-	    (s->buffer[1] == MARKER_SDRST);
-	
-	/* prepare for next SDE */
-	s->x = 0;
-	s->i = 0;
-	s->pseudo = 1;
-	s->at_moves = 0;
-	
-	/* increment layer/stripe/plane loop variables */
-	/* start and end value for each loop: */
-	is[iindex[s->order & 7][STRIPE]] = 0;
-	ie[iindex[s->order & 7][STRIPE]] = s->stripes - 1;
-	is[iindex[s->order & 7][LAYER]] = s->dl;
-	ie[iindex[s->order & 7][LAYER]] = s->d;
-	is[iindex[s->order & 7][PLANE]] = 0;
-	ie[iindex[s->order & 7][PLANE]] = s->planes - 1;
-	i = 2;  /* index to innermost loop */
-	do {
-	  j = 0;  /* carry flag */
-	  if (++s->ii[i] > ie[i]) {
-	    /* handling overflow of loop variable */
-	    j = 1;
-	    if (i > 0)
-	      s->ii[i] = is[i];
-	  }
-	} while (--i >= 0 && j);
-
-	s->buf_len = 0;
-	
-	/* check whether this have been all SDEs */
-	if (j) {
-#ifdef DEBUG
-	  fprintf(stderr, "This was the final SDE in this BIE, "
-		  "%d bytes left.\n", len - *cnt);
-#endif
-	  s->bie_len = 0;
-	  return JBG_EOK;
-	}
-
-	/* check whether we have to abort because of xmax/ymax */
-	if (iindex[s->order & 7][LAYER] == 0 && i < 0) {
-	  /* LAYER is the outermost loop and we have just gone to next layer */
-	  if (jbg_ceil_half(s->xd, s->d - s->ii[0]) > s->xmax ||
-	      jbg_ceil_half(s->yd, s->d - s->ii[0]) > s->ymax) {
-	    s->xmax = 4294967295UL;
-	    s->ymax = 4294967295UL;
-	    return JBG_EOK_INTR;
-	  }
-	  if (s->ii[0] > (unsigned long) s->dmax) {
-	    s->dmax = 256;
-	    return JBG_EOK_INTR;
-	  }
-	}
-
-	break;
-      }
-      s->buf_len = 0;
-
-    } else if (data[*cnt] == MARKER_ESC)
-      s->buffer[s->buf_len++] = data[(*cnt)++];
-
-    else {
-
-      /* we have found PSCD bytes */
-      *cnt += decode_pscd(s, data + *cnt, len - *cnt);
-      if (*cnt < len && data[*cnt] != 0xff) {
-#ifdef DEBUG
-	fprintf(stderr, "PSCD was longer than expected, unread bytes "
-		"%02x %02x %02x %02x ...\n", data[*cnt], data[*cnt+1],
-		data[*cnt+2], data[*cnt+3]);
-#endif
-	return JBG_EINVAL | 14;
-      }
-      
-    }
-  }  /* of BID processing loop 'while (*cnt < len) ...' */
-
-  return JBG_EAGAIN;
-}
-
-
-/*
- * After jbg_dec_in() returned JBG_EOK or JBG_EOK_INTR, you can call this
- * function in order to find out the width of the image. Returns 0 if
- * there is no image available yet.
- */
-unsigned long jbg_dec_getwidth(const struct jbg_dec_state *s)
-{
-  if (s->d < 0)
-    return 0;
-  if (iindex[s->order & 7][LAYER] == 0) {
-    if (s->ii[0] < 1)
-      return 0;
-    else
-      return jbg_ceil_half(s->xd, s->d - (s->ii[0] - 1));
-  }
-
-  return s->xd;
-}
-
-
-/*
- * After jbg_dec_in() returned JBG_EOK or JBG_EOK_INTR, you can call this
- * function in order to find out the height of the image. Returns 0 if
- * there is no image available yet.
- */
-unsigned long jbg_dec_getheight(const struct jbg_dec_state *s)
-{
-  if (s->d < 0)
-    return 0;
-  if (iindex[s->order & 7][LAYER] == 0) {
-    if (s->ii[0] < 1)
-      return 0;
-    else
-      return jbg_ceil_half(s->yd, s->d - (s->ii[0] - 1));
-  }
-  
-  return s->yd;
-}
-
-
-/*
- * After jbg_dec_in() returned JBG_EOK or JBG_EOK_INTR, you can call this
- * function in order to get a pointer to the image. Returns NULL if
- * there is no image available yet.
- */
-unsigned char *jbg_dec_getimage(const struct jbg_dec_state *s, int plane)
-{
-  if (s->d < 0)
-    return NULL;
-  if (iindex[s->order & 7][LAYER] == 0) {
-    if (s->ii[0] < 1)
-      return NULL;
-    else
-      return s->lhp[(s->ii[0] - 1) & 1][plane];
-  }
-  
-  return s->lhp[s->d & 1][plane];
-}
-
-
-/*
- * After jbg_dec_in() returned JBG_EOK or JBG_EOK_INTR, you can call
- * this function in order to find out the size in bytes of one
- * bitplane of the image.
- */
-unsigned long jbg_dec_getsize(const struct jbg_dec_state *s)
-{
-  if (s->d < 0)
-    return 0;
-  if (iindex[s->order & 7][LAYER] == 0) {
-    if (s->ii[0] < 1)
-      return 0;
-    else
-      return 
-	jbg_ceil_half(s->xd, s->d - (s->ii[0] - 1) + 3) * /* overflow risk? */
-	jbg_ceil_half(s->yd, s->d - (s->ii[0] - 1));
-  }
-  
-  return jbg_ceil_half(s->xd, 3) * s->yd;
-}
-
-
-/*
- * After jbg_dec_in() returned JBG_EOK or JBG_EOK_INTR, you can call
- * this function in order to find out the size of the image that you
- * can retrieve with jbg_merge_planes().
- */
-unsigned long jbg_dec_getsize_merged(const struct jbg_dec_state *s)
-{
-  if (s->d < 0)
-    return 0;
-  if (iindex[s->order & 7][LAYER] == 0) {
-    if (s->ii[0] < 1)
-      return 0;
-    else
-      return 
-	jbg_ceil_half(s->xd, s->d - (s->ii[0] - 1)) * /* overflow risk? */
-	jbg_ceil_half(s->yd, s->d - (s->ii[0] - 1)) *
-	((s->planes + 7) / 8);
-  }
-  
-  return s->xd * s->yd * ((s->planes + 7) / 8);
-}
-
-
-/* 
- * The destructor function which releases any resources obtained by the
- * other decoder functions.
- */
-void jbg_dec_free(struct jbg_dec_state *s)
-{
-  int i;
-
-  if (s->d < 0 || s->s == NULL)
-    return;
-  s->d = -2;
-
-  for (i = 0; i < s->planes; i++) {
-    checked_free(s->s[i]);
-    checked_free(s->tx[i]);
-    checked_free(s->ty[i]);
-    checked_free(s->reset[i]);
-    checked_free(s->lntp[i]);
-    checked_free(s->lhp[0][i]);
-    checked_free(s->lhp[1][i]);
-  }
-  
-  checked_free(s->s);
-  checked_free(s->tx);
-  checked_free(s->ty);
-  checked_free(s->reset);
-  checked_free(s->lntp);
-  checked_free(s->lhp[0]);
-  checked_free(s->lhp[1]);
-  if (s->dppriv && s->dppriv != jbg_dptable)
-    checked_free(s->dppriv);
-
-  s->s = NULL;
-
-  return;
-}
-
-
-/*
- * Split bigendian integer pixel field into separate bit planes. In the
- * src array, every pixel is represented by a ((has_planes + 7) / 8) byte
- * long word, most significant byte first. While has_planes describes
- * the number of used bits per pixel in the source image, encode_plane
- * is the number of most significant bits among those that we
- * actually transfer to dest.
- */
-void jbg_split_planes(unsigned long x, unsigned long y, int has_planes,
-		      int encode_planes,
-		      const unsigned char *src, unsigned char **dest,
-		      int use_graycode)
-{
-  unsigned long bpl = jbg_ceil_half(x, 3);  /* bytes per line in dest plane */
-  unsigned long line, i;
-  unsigned k = 8;
-  int p;
-  unsigned prev;     /* previous *src byte shifted by 8 bit to the left */
-  register int bits, msb = has_planes - 1;
-  int bitno;
-
-  /* sanity checks */
-  if (encode_planes > has_planes)
-    encode_planes = has_planes;
-  use_graycode = use_graycode != 0 && encode_planes > 1;
-  
-  for (p = 0; p < encode_planes; p++)
-    memset(dest[p], 0, bpl * y);
-  
-  for (line = 0; line < y; line++) {                 /* lines loop */
-    for (i = 0; i * 8 < x; i++) {                    /* dest bytes loop */
-      for (k = 0; k < 8 && i * 8 + k < x; k++) {     /* pixel loop */
-	prev = 0;
-	for (p = 0; p < encode_planes; p++) {        /* bit planes loop */
-	  /* calculate which bit in *src do we want */
-	  bitno = (msb - p) & 7;
-	  /* put this bit with its left neighbor right adjusted into bits */
-	  bits = (prev | *src) >> bitno;
-	  /* go to next *src byte, but keep old */
-	  if (bitno == 0)
-	    prev = *src++ << 8;
-	  /* make space for inserting new bit */
-	  dest[p][bpl * line + i] <<= 1;
-	  /* insert bit, if requested apply Gray encoding */
-	  dest[p][bpl * line + i] |= (bits ^ (use_graycode & (bits>>1))) & 1;
-	  /*
-	   * Theorem: Let b(n),...,b(1),b(0) be the digits of a
-	   * binary word and let g(n),...,g(1),g(0) be the digits of the
-	   * corresponding Gray code word, then g(i) = b(i) xor b(i+1).
-	   */
-	}
-	/* skip unused *src bytes */
-	for (;p < has_planes; p++)
-	  if (((msb - p) & 7) == 0)
-	    src++;
-      }
-    }
-    for (p = 0; p < encode_planes; p++)              /* right padding loop */
-      dest[p][bpl * (line + 1) - 1] <<= 8 - k;
-  }
-  
-  return;
-}
-
-/* 
- * Merge the separate bit planes decoded by the JBIG decoder into an
- * integer pixel field. This is essentially the counterpart to
- * jbg_split_planes().
- */
-void jbg_dec_merge_planes(const struct jbg_dec_state *s, int use_graycode,
-			  void (*data_out)(unsigned char *start, size_t len,
-					   void *file), void *file)
-{
-#define BUFLEN 4096
-  // int bpp;
-  unsigned long bpl, line, i;
-  unsigned k = 8;
-  int p;
-  unsigned char buf[BUFLEN];
-  unsigned char *bp = buf;
-  unsigned char **src;
-  unsigned long x, y;
-  unsigned v;
-
-  /* sanity check */
-  use_graycode = use_graycode != 0;
-  
-  x = jbg_dec_getwidth(s);
-  y = jbg_dec_getheight(s);
-  if (x == 0 || y == 0)
-    return;
-  // bpp = (s->planes + 7) / 8;   /* bytes per pixel in dest image */
-  bpl = jbg_ceil_half(x, 3);   /* bytes per line in src plane */
-
-  if (iindex[s->order & 7][LAYER] == 0)
-    if (s->ii[0] < 1)
-      return;
-    else
-      src = s->lhp[(s->ii[0] - 1) & 1];
-  else
-    src = s->lhp[s->d & 1];
-  
-  for (line = 0; line < y; line++) {                    /* lines loop */
-    for (i = 0; i * 8 < x; i++) {                       /* src bytes loop */
-      for (k = 0; k < 8 && i * 8 + k < x; k++) {        /* pixel loop */
-	v = 0;
-	for (p = 0; p < s->planes;) {                   /* dest bytes loop */
-	  do {
-	    v = (v << 1) |
-	      (((src[p][bpl * line + i] >> (7 - k)) & 1) ^
-	       (use_graycode & v));
-	  } while ((s->planes - ++p) & 7);
-	  *bp++ = v;
-	  if (bp - buf == BUFLEN) {
-	    data_out(buf, BUFLEN, file);
-	    bp = buf;
-	  }
-	}
-      }
-    }
-  }
-  
-  if (bp - buf > 0)
-    data_out(buf, bp - buf, file);
-  
-  return;
-}
-
-
-/*
- * Given a pointer p to the first byte of either a marker segment or a
- * PSCD, as well as the length len of the remaining data, return
- * either the pointer to the first byte of the next marker segment or
- * PSCD, or p+len if this was the last one, or NULL if some error was
- * encountered. Possible errors are:
- *
- *  - not enough bytes left for complete marker segment
- *  - no marker segment terminates the PSCD
- *  - unknown marker code encountered
- *  
- */
-unsigned char *jbg_next_pscdms(unsigned char *p, size_t len)
-{
-  unsigned char *pp;
-  unsigned long l;
-
-  if (len < 2)
-    return NULL; /* not enough bytes left for complete marker segment */
-
-  if (p[0] != MARKER_ESC || p[1] == MARKER_STUFF) {
-    do {
-      while (p[0] == MARKER_ESC && p[1] == MARKER_STUFF) {
-	p += 2;
-	len -= 2;
-	if (len < 2)
-	  return NULL; /* not enough bytes left for complete marker segment */
-      }
-      assert(len >= 2);
-      pp = (unsigned char *) memchr(p, MARKER_ESC, len - 1);
-      if (!pp)
-	return NULL; /* no marker segment terminates the PSCD */
-      l = pp - p;
-      assert(l < len);
-      p += l;
-      len -= l;
-    } while (p[1] == MARKER_STUFF);
-  } else {
-    switch (p[1]) {
-    case MARKER_SDNORM:
-    case MARKER_SDRST:
-    case MARKER_ABORT:
-      return p + 2;
-    case MARKER_NEWLEN:
-      if (len < 6)
-	return NULL; /* not enough bytes left for complete marker segment */
-      return p + 6;
-    case MARKER_ATMOVE:
-      if (len < 8)
-	return NULL; /* not enough bytes left for complete marker segment */
-      return p + 8;
-    case MARKER_COMMENT:
-      if (len < 6)
-	return NULL; /* not enough bytes left for complete marker segment */
-      l = (((long) p[2] << 24) | ((long) p[3] << 16) |
-	   ((long) p[4] <<  8) |  (long) p[5]);
-      if (len - 6 < l)
-	return NULL; /* not enough bytes left for complete marker segment */
-      return p + 6 + l;
-    default:
-      /* unknown marker sequence encountered */
-      return NULL;
-    }
-  }
-
-  return p;
-}
-
-
-/*
- * Scan a complete BIE for a NEWLEN marker segment, then read the new
- * YD value found in it and use it to overwrite the one in the BIE
- * header. Use this procedure if a BIE initially declares an
- * unreasonably high provisional YD value (e.g., 0xffffffff) or
- * depends on the fact that section 6.2.6.2 of ITU-T T.82 says that a
- * NEWLEN marker segment "could refer to a line in the immediately
- * preceding stripe due to an unexpected termination of the image or
- * the use of only such stripe". ITU-T.85 explicitely suggests the
- * use of this for fax machines that start transmission before having
- * encountered the end of the page. None of this is necessary for
- * BIEs produced by JBIG-KIT, which normally does not use NEWLEN.
- */
-int jbg_newlen(unsigned char *bie, size_t len)
-{
-  unsigned char *p = bie + 20;
-  int i;
-
-  if (len < 20)
-    return JBG_EAGAIN;
-  if ((bie[19] & (JBG_DPON | JBG_DPPRIV | JBG_DPLAST))
-      == (JBG_DPON | JBG_DPPRIV))
-    p += 1728; /* skip DPTABLE */
-  if (p >= bie + len)
-    return JBG_EAGAIN;
-
-  while ((p = jbg_next_pscdms(p, len - (p - bie)))) {
-    if (p == bie + len)
-      return JBG_EOK;
-    else if (p[0] == MARKER_ESC)
-      switch (p[1]) {
-      case MARKER_NEWLEN:
-	/* overwrite YD in BIH with YD from NEWLEN */
-	for (i = 0; i < 4; i++) {
-	  bie[8+i] = p[2+i];
-	}
-	return JBG_EOK;
-      case MARKER_ABORT:
-	return JBG_EABORT;
-      }
-  }
-  return JBG_EINVAL | 0;
-}
diff -uNr foo2zjs-patch1/jbig.h foo2zjs/jbig.h
--- foo2zjs-patch1/jbig.h	2008-09-05 17:06:03.000000000 +0200
+++ foo2zjs/jbig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/*
- *  Header file for the portable JBIG compression library
- *
- *  Copyright 1995-2008 -- Markus Kuhn -- http://www.cl.cam.ac.uk/~mgk25/
- *
- *  $Id: jbig.h,v 1.4 2008/09/05 15:05:54 rick Exp $
- */
-
-#ifndef JBG_H
-#define JBG_H
-
-#include <stddef.h>
-#include "jbig_ar.h"
-
-/*
- * JBIG-KIT version number
- */
-
-#define JBG_VERSION    "2.0"
-
-/*
- * JBIG-KIT licence agreement reference code:
- * If you use JBIG-KIT under a commercial licence, please replace
- * below the letters GPL with the reference code that you received
- * with your licence agreement. (This code is typically a letter "A"
- * followed by four decimal digits, e.g. "A1234".)
- */
-
-#define JBG_LICENCE    "GPL"
-
-/*
- * Buffer block for SDEs which are temporarily stored by encoder
- */
-
-#define JBG_BUFSIZE 4000
-
-struct jbg_buf {
-  unsigned char d[JBG_BUFSIZE];              /* one block of a buffer list */
-  int len;                             /* length of the data in this block */
-  struct jbg_buf *next;                           /* pointer to next block */
-  struct jbg_buf *previous;                   /* pointer to previous block *
-					       * (unused in freelist)      */
-  struct jbg_buf *last;     /* only used in list head: final block of list */
-  struct jbg_buf **free_list;   /* pointer to pointer to head of free list */
-};
-
-/*
- * Maximum number of ATMOVEs per stripe that decoder can handle
- */
-
-#define JBG_ATMOVES_MAX  64
-
-/*
- * Option and order flags
- */
-
-#define JBG_HITOLO     0x08
-#define JBG_SEQ        0x04
-#define JBG_ILEAVE     0x02
-#define JBG_SMID       0x01
-
-#define JBG_LRLTWO     0x40
-#define JBG_VLENGTH    0x20
-#define JBG_TPDON      0x10
-#define JBG_TPBON      0x08
-#define JBG_DPON       0x04
-#define JBG_DPPRIV     0x02
-#define JBG_DPLAST     0x01
-
-/* encoding options that will not be indicated in the header */
-
-#define JBG_DELAY_AT   0x100  /* Delay ATMOVE until the first line of the next
-			       * stripe. Option available for compatibility
-			       * with conformance test example in clause 7.2. */
-
-#define JBG_SDRST      0x200  /* Use SDRST instead of SDNORM. This option is
-			       * there for anyone who needs to generate
-			       * test data that covers the SDRST cases. */
-
-/*
- * Possible error code return values
- */
-
-#define JBG_EOK        (0 << 4)
-#define JBG_EOK_INTR   (1 << 4)
-#define JBG_EAGAIN     (2 << 4)
-#define JBG_ENOMEM     (3 << 4)
-#define JBG_EABORT     (4 << 4)
-#define JBG_EMARKER    (5 << 4)
-#define JBG_EINVAL     (6 << 4)
-#define JBG_EIMPL      (7 << 4)
-#define JBG_ENOCONT    (8 << 4)
-
-/*
- * Status of a JBIG encoder
- */
-
-struct jbg_enc_state {
-  int d;                            /* resolution layer of the input image */
-  unsigned long xd, yd;    /* size of the input image (resolution layer d) */
-  unsigned long yd1;    /* BIH announced height of image, use yd1 != yd to
-                        emulate T.85-style NEWLEN height updates for tests */
-  int planes;                         /* number of different bitmap planes */
-  int dl;                       /* lowest resolution layer in the next BIE */
-  int dh;                      /* highest resolution layer in the next BIE */
-  unsigned long l0;                /* number of lines per stripe at lowest *
-                                    * resolution layer 0                   */
-  unsigned long stripes;    /* number of stripes required  (determ. by l0) */
-  unsigned char **lhp[2];    /* pointers to lower/higher resolution images */
-  int *highres;                 /* index [plane] of highres image in lhp[] */
-  int order;                                    /* SDE ordering parameters */
-  int options;                                      /* encoding parameters */
-  unsigned mx, my;                           /* maximum ATMOVE window size */
-  int *tx;       /* array [plane] with x-offset of adaptive template pixel */
-  char *dppriv;         /* optional private deterministic prediction table */
-  char *res_tab;           /* table for the resolution reduction algorithm */
-  struct jbg_buf ****sde;      /* array [stripe][layer][plane] pointers to *
-				* buffers for stored SDEs                  */
-  struct jbg_arenc_state *s;  /* array [planes] for arithm. encoder status */
-  struct jbg_buf *free_list; /* list of currently unused SDE block buffers */
-  void (*data_out)(unsigned char *start, size_t len, void *file);
-                                                    /* data write callback */
-  void *file;                            /* parameter passed to data_out() */
-  char *tp;    /* buffer for temp. values used by diff. typical prediction */
-  unsigned char *comment; /* content of comment marker segment to be added
-                             at next opportunity (will be reset to NULL
-                             as soon as comment has been written)          */
-  unsigned long comment_len;       /* length of data pointed to by comment */
-};
-
-
-/*
- * Status of a JBIG decoder
- */
-
-struct jbg_dec_state {
-  /* data from BIH */
-  int d;                             /* resolution layer of the full image */
-  int dl;                            /* first resolution layer in this BIE */
-  unsigned long xd, yd;     /* size of the full image (resolution layer d) */
-  int planes;                         /* number of different bitmap planes */
-  unsigned long l0;                /* number of lines per stripe at lowest *
-				    * resolution layer 0                   */
-  unsigned long stripes;    /* number of stripes required  (determ. by l0) */
-  int order;                                    /* SDE ordering parameters */
-  int options;                                      /* encoding parameters */
-  int mx, my;                                /* maximum ATMOVE window size */
-  char *dppriv;         /* optional private deterministic prediction table */
-
-  /* loop variables */
-  unsigned long ii[3];  /* current stripe, layer, plane (outer loop first) */
-
-  /*
-   * Pointers to array [planes] of lower/higher resolution images.
-   * lhp[d & 1] contains image of layer d. 
-   */
-  unsigned char **lhp[2];
-
-  /* status information */
-  int **tx, **ty;   /* array [plane][layer-dl] with x,y-offset of AT pixel */
-  struct jbg_ardec_state **s;    /* array [plane][layer-dl] for arithmetic *
-				  * decoder status */
-  int **reset;     /* array [plane][layer-dl] remembers if previous stripe *
-		    * in that plane/resolution ended with SDRST.           */
-  unsigned long bie_len;                    /* number of bytes read so far */
-  unsigned char buffer[20]; /* used to store BIH or marker segments fragm. */
-  int buf_len;                                /* number of bytes in buffer */
-  unsigned long comment_skip;      /* remaining bytes of a COMMENT segment */
-  unsigned long x;              /* x position of next pixel in current SDE */
-  unsigned long i; /* line in current SDE (first line of each stripe is 0) */ 
-  int at_moves;                /* number of AT moves in the current stripe */
-  unsigned long at_line[JBG_ATMOVES_MAX];           /* lines at which an   *
-					             * AT move will happen */
-  int at_tx[JBG_ATMOVES_MAX], at_ty[JBG_ATMOVES_MAX]; /* ATMOVE offsets in *
-						       * current stripe    */
-  unsigned long line_h1, line_h2, line_h3;     /* variables of decode_pscd */
-  unsigned long line_l1, line_l2, line_l3;
-  int pseudo;         /* flag for TPBON/TPDON:  next pixel is pseudo pixel */
-  int **lntp;        /* flag [plane][layer-dl] for TP: line is not typical */
-
-  unsigned long xmax, ymax;         /* if possible abort before image gets *
-				     * larger than this size */
-  int dmax;                                      /* abort after this layer */
-};
-
-
-/* some macros (too trivial for a function) */
-
-#define jbg_dec_getplanes(s)     ((s)->planes)
-
-
-/* function prototypes */
-
-void jbg_enc_init(struct jbg_enc_state *s, unsigned long x, unsigned long y,
-		  int planes, unsigned char **p,
-		  void (*data_out)(unsigned char *start, size_t len,
-				   void *file),
-		  void *file);
-int jbg_enc_lrlmax(struct jbg_enc_state *s, unsigned long mwidth,
-		   unsigned long mheight);
-void jbg_enc_layers(struct jbg_enc_state *s, int d);
-int  jbg_enc_lrange(struct jbg_enc_state *s, int dl, int dh);
-void jbg_enc_options(struct jbg_enc_state *s, int order, int options,
-		     unsigned long l0, int mx, int my);
-void jbg_enc_out(struct jbg_enc_state *s);
-void jbg_enc_free(struct jbg_enc_state *s);
-
-void jbg_dec_init(struct jbg_dec_state *s);
-void jbg_dec_maxsize(struct jbg_dec_state *s, unsigned long xmax,
-		     unsigned long ymax);
-int  jbg_dec_in(struct jbg_dec_state *s, unsigned char *data, size_t len,
-		size_t *cnt);
-unsigned long jbg_dec_getwidth(const struct jbg_dec_state *s);
-unsigned long jbg_dec_getheight(const struct jbg_dec_state *s);
-unsigned char *jbg_dec_getimage(const struct jbg_dec_state *s, int plane);
-unsigned long jbg_dec_getsize(const struct jbg_dec_state *s);
-void jbg_dec_merge_planes(const struct jbg_dec_state *s, int use_graycode,
-			  void (*data_out)(unsigned char *start, size_t len,
-					   void *file), void *file);
-unsigned long jbg_dec_getsize_merged(const struct jbg_dec_state *s);
-void jbg_dec_free(struct jbg_dec_state *s);
-
-const char *jbg_strerror(int errnum);
-void jbg_int2dppriv(unsigned char *dptable, const char *internal);
-void jbg_dppriv2int(char *internal, const unsigned char *dptable);
-unsigned long jbg_ceil_half(unsigned long x, int n);
-void jbg_split_planes(unsigned long x, unsigned long y, int has_planes,
-		      int encode_planes,
-		      const unsigned char *src, unsigned char **dest,
-		      int use_graycode);
-int jbg_newlen(unsigned char *bie, size_t len);
-
-#endif /* JBG_H */
diff -uNr foo2zjs-patch1/Makefile foo2zjs/Makefile
--- foo2zjs-patch1/Makefile	2013-03-02 17:46:05.000000000 +0100
+++ foo2zjs/Makefile	2013-03-03 08:36:20.139826214 +0100
@@ -19,7 +19,6 @@
 # Installation prefix...
 PREFIX=/usr/local
 PREFIX=/usr
-PREFIX=$(DESTDIR)/usr
 
 # Pathnames for this package...
 BIN=$(PREFIX)/bin
@@ -38,7 +37,7 @@
 ROOT=root
 
 # Pathnames for referenced packages...
-FOODB=$(DESTDIR)/usr/share/foomatic/db/source
+FOODB=/usr/share/foomatic/db/source
 
 # User ID's
 LPuid=-oroot
@@ -127,10 +126,6 @@
 		Makefile \
 		foo2zjs.c \
 		foo2zjs.1in \
-		jbig.c \
-		jbig.h \
-		jbig_ar.c \
-		jbig_ar.h \
 		zjsdecode.c \
 		zjsdecode.1in \
 		zjs.h \
@@ -282,7 +277,7 @@
 MANPAGES+=	gipddecode.1
 MANPAGES+=	foo2zjs-pstops.1 arm2hpdl.1 usb_printerid.1
 MANPAGES+=	printer-profile.1
-LIBJBG	=	jbig.o jbig_ar.o
+LIBJBG	=	-ljbig
 BINPROGS=
 
 ifeq ($(UNAME),Linux)
@@ -449,32 +444,32 @@
 	@echo "yourself."
 
 
-foo2zjs: foo2zjs.o $(LIBJBG)
+foo2zjs: foo2zjs.o
 	$(CC) $(CFLAGS) -o $@ foo2zjs.o $(LIBJBG)
 
-foo2hp: foo2hp.o $(LIBJBG)
+foo2hp: foo2hp.o
 	# $(CC) $(CFLAGS) -o $@ foo2hp.o $(LIBJBG) /usr/local/lib/libdmalloc.a
 	$(CC) $(CFLAGS) -o $@ foo2hp.o $(LIBJBG)
 
-foo2xqx: foo2xqx.o $(LIBJBG)
+foo2xqx: foo2xqx.o 
 	$(CC) $(CFLAGS) -o $@ foo2xqx.o $(LIBJBG)
 
-foo2lava: foo2lava.o $(LIBJBG)
+foo2lava: foo2lava.o 
 	$(CC) $(CFLAGS) -o $@ foo2lava.o $(LIBJBG)
 
-foo2qpdl: foo2qpdl.o $(LIBJBG)
+foo2qpdl: foo2qpdl.o 
 	$(CC) $(CFLAGS) -o $@ foo2qpdl.o $(LIBJBG)
 
-foo2oak: foo2oak.o $(LIBJBG)
+foo2oak: foo2oak.o 
 	$(CC) $(CFLAGS) -o $@ foo2oak.o $(LIBJBG)
 
-foo2slx: foo2slx.o $(LIBJBG)
+foo2slx: foo2slx.o 
 	$(CC) $(CFLAGS) -o $@ foo2slx.o $(LIBJBG)
 
-foo2hiperc: foo2hiperc.o $(LIBJBG)
+foo2hiperc: foo2hiperc.o 
 	$(CC) $(CFLAGS) -o $@ foo2hiperc.o $(LIBJBG)
 
-foo2hbpl2: foo2hbpl2.o $(LIBJBG)
+foo2hbpl2: foo2hbpl2.o 
 	$(CC) $(CFLAGS) -o $@ foo2hbpl2.o $(LIBJBG)
 
 
@@ -554,40 +549,40 @@
 	cd osx-hotplug; $(MAKE) all
 endif
 
-ok: ok.o $(LIBJBG)
+ok: ok.o 
 	$(CC) $(CFLAGS) ok.o $(LIBJBG) -o $@
 
-gipddecode: gipddecode.o $(LIBJBG)
+gipddecode: gipddecode.o 
 	$(CC) $(CFLAGS) gipddecode.o $(LIBJBG) -o $@
 
-hbpldecode: hbpldecode.o $(LIBJBG)
+hbpldecode: hbpldecode.o
 	$(CC) $(CFLAGS) hbpldecode.o $(LIBJBG) -o $@
 
-hipercdecode: hipercdecode.o $(LIBJBG)
+hipercdecode: hipercdecode.o 
 	$(CC) $(CFLAGS) hipercdecode.o $(LIBJBG) -o $@
 
-lavadecode: lavadecode.o $(LIBJBG)
+lavadecode: lavadecode.o 
 	$(CC) $(CFLAGS) lavadecode.o $(LIBJBG) -o $@
 
-oakdecode: oakdecode.o $(LIBJBG)
+oakdecode: oakdecode.o 
 	$(CC) $(CFLAGS) -g oakdecode.o $(LIBJBG) -o $@
 
-opldecode: opldecode.o $(LIBJBG)
+opldecode: opldecode.o 
 	$(CC) $(CFLAGS) -g opldecode.o $(LIBJBG) -o $@
 
-qpdldecode: qpdldecode.o $(LIBJBG)
+qpdldecode: qpdldecode.o 
 	$(CC) $(CFLAGS) qpdldecode.o $(LIBJBG) -o $@
 
-splcdecode: splcdecode.o $(LIBJBG)
+splcdecode: splcdecode.o 
 	$(CC) $(CFLAGS) splcdecode.o $(LIBJBG) -lz -o $@
 
-slxdecode: slxdecode.o $(LIBJBG)
+slxdecode: slxdecode.o
 	$(CC) $(CFLAGS) slxdecode.o $(LIBJBG) -o $@
 
-xqxdecode: xqxdecode.o $(LIBJBG)
+xqxdecode: xqxdecode.o 
 	$(CC) $(CFLAGS) xqxdecode.o $(LIBJBG) -o $@
 
-zjsdecode: zjsdecode.o $(LIBJBG)
+zjsdecode: zjsdecode.o
 	$(CC) $(CFLAGS) zjsdecode.o $(LIBJBG) -o $@
 
 command2foo2lava-pjl: command2foo2lava-pjl.o
@@ -894,9 +889,9 @@
 	    done; \
 	fi
 
-APPL=$(DESTDIR)/usr/share/applications
-OLDAPPL=$(DESTDIR)/usr/share/gnome/apps/System
-PIXMAPS=$(DESTDIR)/usr/share/pixmaps
+APPL=/usr/share/applications
+OLDAPPL=/usr/share/gnome/apps/System
+PIXMAPS=/usr/share/pixmaps
 
 install-desktop:
 	#
@@ -1143,7 +1138,7 @@
 	-rm -f $(PROGS) $(BINPROGS) $(SHELLS)
 	-rm -f *.zc *.zm
 	-rm -f xxx.* xxxomatic
-	-rm -f foo2zjs.o jbig.o jbig_ar.o zjsdecode.o foo2hp.o
+	-rm -f foo2zjs.o zjsdecode.o foo2hp.o
 	-rm -f foo2oak.o oakdecode.o
 	-rm -f foo2xqx.o xqxdecode.o
 	-rm -f foo2lava.o lavadecode.o
@@ -1171,25 +1166,25 @@
 #
 # Header dependencies
 #
-zjsdecode.o: jbig.h zjs.h
-foo2zjs.o: jbig.h zjs.h
-foo2oak.o: jbig.h oak.h
-jbig.o: jbig.h
-foo2hp.o: jbig.h zjs.h cups.h
-foo2xqx.o: jbig.h xqx.h
-foo2lava.o: jbig.h
-foo2qpdl.o: jbig.h qpdl.h
-foo2slx.o: jbig.h slx.h
-foo2hiperc.o: jbig.h hiperc.h
-foo2hbpl2.o: jbig.h hbpl.h
-hipercdecode.o: hiperc.h jbig.h
-hbpldecode.o: jbig.h
-lavadecode.o: jbig.h
-qpdldecode.o: jbig.h
-opldecode.o: jbig.h
-slxdecode.o: slx.h jbig.h
-xqxdecode.o: xqx.h jbig.h
-gipddecode.o: slx.h jbig.h
+zjsdecode.o: zjs.h
+foo2zjs.o: zjs.h
+foo2oak.o: oak.h
+jbig.o: 
+foo2hp.o:  zjs.h cups.h
+foo2xqx.o:  xqx.h
+foo2lava.o:
+foo2qpdl.o: qpdl.h
+foo2slx.o: slx.h
+foo2hiperc.o: hiperc.h
+foo2hbpl2.o: hbpl.h
+hipercdecode.o: hiperc.h
+hbpldecode.o: 
+lavadecode.o: 
+qpdldecode.o: 
+opldecode.o: 
+slxdecode.o: slx.h 
+xqxdecode.o: xqx.h 
+gipddecode.o: slx.h 
 
 #
 # foo2* Regression tests
@@ -1493,11 +1488,10 @@
 
 GROFF=/usr/local/test/bin/groff
 GROFF=groff
-manual.pdf: $(MANPAGES) icc2ps/foo2zjs-icc2ps.1 osx-hotplug/osx-hplj-hotplug.1
+manual.pdf: $(MANPAGES) icc2ps/foo2zjs-icc2ps.1
 	-$(GROFF) -t -man \
 	    `ls $(MANPAGES) \
 		icc2ps/foo2zjs-icc2ps.1 \
-		osx-hotplug/osx-hplj-hotplug.1 \
 		| sort` \
 	    | ps2pdf - $@
 
diff -uNr foo2zjs-patch1/Makefile~ foo2zjs/Makefile~
--- foo2zjs-patch1/Makefile~	1970-01-01 01:00:00.000000000 +0100
+++ foo2zjs/Makefile~	2013-03-03 08:30:31.056916564 +0100
@@ -0,0 +1,1821 @@
+LANG=C
+UNAME := $(shell uname)
+MACH := $(shell uname -m | sed 's/i.86/x86_32/')
+
+ifeq ($(UNAME),SunOS)
+    EUID := $(shell /usr/xpg4/bin/id -u)
+    SHELL=bash
+    CC=gcc
+    OLDGROFF=OLDGROFF
+else
+    EUID := $(shell id -u)
+endif
+
+SYSNAME := $(shell uname -n)
+
+# No version number yet...
+VERSION=0.0
+
+# Installation prefix...
+PREFIX=/usr/local
+PREFIX=/usr
+
+# Pathnames for this package...
+BIN=$(PREFIX)/bin
+SHAREZJS=$(PREFIX)/share/foo2zjs
+SHAREOAK=$(PREFIX)/share/foo2oak
+SHAREHP=$(PREFIX)/share/foo2hp
+SHAREXQX=$(PREFIX)/share/foo2xqx
+SHARELAVA=$(PREFIX)/share/foo2lava
+SHAREQPDL=$(PREFIX)/share/foo2qpdl
+SHARESLX=$(PREFIX)/share/foo2slx
+SHAREHC=$(PREFIX)/share/foo2hiperc
+SHAREHBPL=$(PREFIX)/share/foo2hbpl
+MANDIR=$(PREFIX)/share/man
+DOCDIR=$(PREFIX)/share/doc/foo2zjs/
+INSTALL=install
+ROOT=root
+
+# Pathnames for referenced packages...
+FOODB=/usr/share/foomatic/db/source
+
+# User ID's
+LPuid=-oroot
+LPgid=-glp
+ifeq ($(UNAME),Darwin)
+    LPuid=-oroot
+    LPgid=-gwheel
+    #ROOT=sudo
+endif
+ifeq ($(UNAME),FreeBSD)
+    LPuid=-oroot
+    LPgid=-gwheel
+endif
+ifeq ($(UNAME),OpenBSD)
+    LPuid=-oroot
+    LPgid=-gwheel
+endif
+ifeq ($(UNAME),SunOS)
+    LPuid=-oroot
+    LPgid=-glp
+    INSTALL=/usr/ucb/install
+endif
+# If we aren't root, don't try to set ownership
+ifneq ($(EUID),0)
+    LPuid=
+    LPgid=
+endif
+
+# Definition of modtime()
+MODTIME= date -d "1/1/1970 utc + `stat -t $$1 | cut -f14 -d' '` seconds" "+%a %b %d %T %Y"
+ifeq ($(UNAME),FreeBSD)
+    MODTIME= stat -f "%Sm" -t "%a %b %d %T %Y" $$1
+endif
+ifeq ($(UNAME),OpenBSD)
+    MODTIME= stat -f "%Sm" -t "%a %b %d %T %Y" $$1
+endif
+ifeq ($(UNAME),Darwin)
+    MODTIME= stat -f "%Sm" -t "%a %b %d %T %Y" $$1
+endif
+ifeq ($(UNAME),SunOS)
+    MODTIME= `ls -e $$1 | cut -c42-61`
+endif
+
+#
+# Files for tarball
+#
+NULL=
+WEBFILES=	\
+		foo2zjs.html.in \
+		style.css \
+		archzjs.fig \
+		2300.png \
+		2430.png \
+		1020.png \
+		foo2oak.html.in \
+		archoak.fig \
+		1500.gif \
+		foo2hp.html.in \
+		archhp.fig \
+		2600.gif \
+		foo2xqx.html.in \
+		archxqx.fig \
+		m1005.gif \
+		foo2lava.html.in \
+		archlava.fig \
+		2530.gif \
+		foo2qpdl.html.in \
+		archqplp.fig \
+		foo2slx.html.in \
+		archslx.fig \
+		c500n.png \
+		foo2hiperc.html.in \
+		archhiperc.fig \
+		c3400n.png \
+		$(NULL)
+	
+FILES	=	\
+		README \
+		README.in \
+		INSTALL \
+		INSTALL.in \
+		INSTALL.osx \
+		INSTALL.usb \
+		COPYING \
+		ChangeLog \
+		Makefile \
+		foo2zjs.c \
+		foo2zjs.1in \
+		zjsdecode.c \
+		zjsdecode.1in \
+		zjs.h \
+		foo2hp.c \
+		foo2hp.1in \
+		foo2xqx.c \
+		foo2xqx.1in \
+		foo2lava.c \
+		foo2lava.1in \
+		foo2qpdl.c \
+		foo2qpdl.1in \
+		foo2slx.c \
+		foo2slx.1in \
+		foo2hiperc.c \
+		foo2hiperc.1in \
+		hbpl.h \
+		foo2hbpl2.c \
+		foo2hbpl2.1in \
+		cups.h \
+		xqx.h \
+		xqxdecode.c \
+		xqxdecode.1in \
+		lavadecode.c \
+		lavadecode.1in \
+		qpdl.h \
+		qpdldecode.c \
+		qpdldecode.1in \
+		opldecode.c \
+		opldecode.1in \
+		slx.h \
+		slxdecode.c \
+		slxdecode.1in \
+		gipddecode.c \
+		gipddecode.1in \
+		hbpldecode.c \
+		hbpldecode.1in \
+		foo2zjs-wrapper.in \
+		foo2zjs-wrapper.1in \
+		foo2hp2600-wrapper.in \
+		foo2hp2600-wrapper.1in \
+		foo2xqx-wrapper.in \
+		foo2xqx-wrapper.1in \
+		foo2lava-wrapper.in \
+		foo2lava-wrapper.1in \
+		foo2qpdl-wrapper.in \
+		foo2qpdl-wrapper.1in \
+		foo2slx-wrapper.in \
+		foo2slx-wrapper.1in \
+		foo2hiperc-wrapper.in \
+		foo2hiperc-wrapper.1in \
+		foo2hbpl2-wrapper.in \
+		foo2hbpl2-wrapper.1in \
+		gamma.ps \
+		gamma-lookup.ps \
+		align.ps \
+		testpage.ps \
+		foomatic-db/*/*.xml \
+		foomatic-test \
+		getweb.in \
+		icc2ps/*.[ch] \
+		icc2ps/*.1in \
+		icc2ps/Makefile \
+		icc2ps/AUTHORS \
+		icc2ps/COPYING \
+		icc2ps/README \
+		icc2ps/README.foo2zjs \
+		osx-hotplug/Makefile \
+		osx-hotplug/*.m \
+		osx-hotplug/*.1in \
+		ppd-adjust \
+		PPD/*.ppd \
+		crd/zjs/*.crd \
+		crd/zjs/*.ps \
+		crd/qpdl/*cms* \
+		crd/qpdl/*.ps \
+		arm2hpdl.c \
+		arm2hpdl.1in \
+		usb_printerid.c \
+		usb_printerid.1in \
+		hplj1000 \
+		hplj10xx.rules* \
+		msexpand \
+		oak.h \
+		foo2oak.c \
+		foo2oak.1in \
+		oakdecode.c \
+		oakdecode.1in \
+		foo2oak-wrapper.in \
+		foo2oak-wrapper.1in \
+		hiperc.h \
+		hipercdecode.c \
+		hipercdecode.1in \
+		c5200mono.prn \
+		foo2zjs-pstops.sh \
+		foo2zjs-pstops.1in \
+		hplj1020.desktop \
+		hplj1020_icon.png \
+		hplj1020_icon.gif \
+		hplj10xx_gui.tcl \
+		includer-man \
+		macros.man \
+		regress.txt \
+		printer-profile.sh \
+		printer-profile.1in \
+		freebsd-install \
+		hplj10xx.conf \
+		modify-ppd \
+		command2foo2lava-pjl.c \
+		$(NULL)
+
+# CUPS vars
+CUPS_SERVERBIN := $(DESTDIR)$(shell cups-config --serverbin 2>/dev/null)
+CUPS_DEVEL := $(shell grep cupsSideChannelDoRequest /usr/include/cups/sidechannel.h 2>/dev/null)
+CUPS_GOODAPI := $(shell cups-config --api-version 2>/dev/null | sed "s/1\.[0123].*//")
+
+# hpclj2600n-0.icm km2430_0.icm km2430_1.icm km2430_2.icm samclp300-0.icm
+# sihp1000.img sihp1005.img sihp1020.img sihp1018.img
+# sihpP1005.img sihpP1006.img sihpP1505.img
+
+# Programs and libraries
+PROGS=		foo2zjs zjsdecode arm2hpdl foo2hp foo2xqx xqxdecode
+PROGS+=		foo2lava lavadecode foo2qpdl qpdldecode opldecode
+PROGS+=		foo2oak oakdecode
+PROGS+=		foo2slx slxdecode
+PROGS+=		foo2hiperc hipercdecode
+PROGS+=		foo2hbpl2 hbpldecode
+PROGS+=		gipddecode
+ifneq ($(CUPS_SERVERBIN),)
+    ifneq ($(CUPS_DEVEL),)
+	ifneq ($(CUPS_GOODAPI),)
+	    PROGS+=	command2foo2lava-pjl
+	endif
+    endif
+endif
+SHELLS=		foo2zjs-wrapper foo2oak-wrapper foo2hp2600-wrapper \
+		foo2xqx-wrapper foo2lava-wrapper foo2qpdl-wrapper \
+		foo2slx-wrapper foo2hiperc-wrapper foo2hbpl2-wrapper
+SHELLS+=	foo2zjs-pstops
+SHELLS+=	printer-profile
+MANPAGES=	foo2zjs-wrapper.1 foo2zjs.1 zjsdecode.1
+MANPAGES+=	foo2oak-wrapper.1 foo2oak.1 oakdecode.1
+MANPAGES+=	foo2hp2600-wrapper.1 foo2hp.1
+MANPAGES+=	foo2xqx-wrapper.1 foo2xqx.1 xqxdecode.1
+MANPAGES+=	foo2lava-wrapper.1 foo2lava.1 lavadecode.1 opldecode.1
+MANPAGES+=	foo2qpdl-wrapper.1 foo2qpdl.1 qpdldecode.1
+MANPAGES+=	foo2slx-wrapper.1 foo2slx.1 slxdecode.1
+MANPAGES+=	foo2hiperc-wrapper.1 foo2hiperc.1 hipercdecode.1
+MANPAGES+=	foo2hbpl2-wrapper.1 foo2hbpl2.1 hbpldecode.1
+MANPAGES+=	gipddecode.1
+MANPAGES+=	foo2zjs-pstops.1 arm2hpdl.1 usb_printerid.1
+MANPAGES+=	printer-profile.1
+LIBJBG	=	-ljbig
+BINPROGS=
+
+ifeq ($(UNAME),Linux)
+	BINPROGS += usb_printerid
+endif
+
+# Compiler flags
+#CFLAGS +=	-O2 -Wall -Wno-unused-but-set-variable
+CFLAGS +=	-O2 -Wall 
+#CFLAGS +=	-g
+
+#
+# Rules to create test documents
+#
+GX=10200
+GY=6600
+GXR=1200
+GYR=600
+GSOPTS=	-q -dBATCH -dSAFER -dQUIET -dNOPAUSE -sPAPERSIZE=letter -r$(GXR)x$(GYR)
+JBGOPTS=-m 16 -d 0 -p 92	# Equivalent options for pbmtojbg
+
+.SUFFIXES: .ps .pbm .pgm .pgm2 .ppm .ppm2 .zjs .cmyk .pksm .zc .zm .jbg \
+	   .cups .cupm .1 .1in .fig .gif .xqx .lava .qpdl .slx .hc .hbpl
+
+.fig.gif:
+	fig2dev -L gif $*.fig | giftrans -t "#ffffff" -o $*.gif
+	# fig2dev -L ppm  $*.fig | pnmquant -fs 256 \
+	    #| ppmtogif -transparent rgb:ff/ff/ff >$*.gif
+
+.ps.cups:
+	gs $(GSOPTS) -r600x600 \
+	    -dcupsColorSpace=6 -dcupsBitsPerColor=2 -dcupsColorOrder=2 \
+	    -sDEVICE=cups -sOutputFile=$*.cups $*.ps
+
+.ps.cupm:
+	gs $(GSOPTS) -r600x600 \
+	    -dcupsColorSpace=3 -dcupsBitsPerColor=2 -dcupsColorOrder=2 \
+	    -sDEVICE=cups -sOutputFile=$*.cupm $*.ps
+
+.ps.pbm:
+	gs $(GSOPTS) -sDEVICE=pbmraw -sOutputFile=$*.pbm $*.ps
+
+.ps.ppm:
+	gs $(GSOPTS) -sDEVICE=ppmraw -sOutputFile=$*.ppm $*.ps
+
+.ps.pgm:
+	gs $(GSOPTS) -sDEVICE=pgmraw -sOutputFile=- $*.ps \
+	| pnmdepth 3 > $*.pgm
+
+.ps.pgm2:
+	gs.rick $(GSOPTS) -sDEVICE=pgmraw2 -sOutputFile=$*.pgm2 $*.ps
+
+.ps.cmyk:
+	gs $(GSOPTS) -sDEVICE=bitcmyk -sOutputFile=$*.cmyk $*.ps
+
+.ps.pksm:
+	gs $(GSOPTS) -sDEVICE=pksmraw -sOutputFile=$*.pksm $*.ps
+
+.ps.zc:
+	gs $(GSOPTS) -sDEVICE=bitcmyk -sOutputFile=- - < $*.ps \
+	| ./foo2zjs -r1200x600 -g10200x6600 -p1 >$*.zc
+
+.ps.zm:
+	gs $(GSOPTS) -sDEVICE=pbmraw -sOutputFile=- - < $*.ps \
+	| ./foo2zjs -r1200x600 -g10200x6600 -p1 >$*.zm
+
+.pbm.zjs:
+	./foo2zjs < $*.pbm > $*.zjs
+
+.cmyk.zjs:
+	./foo2zjs < $*.cmyk > $*.zjs
+
+.pksm.zjs:
+	./foo2zjs < $*.pksm > $*.zjs
+
+.pbm.xqx:
+	./foo2xqx < $*.pbm > $*.xqx
+
+.pbm.qpdl:
+	./foo2qpdl < $*.pbm > $*.qpdl
+
+.pbm.slx:
+	./foo2slx < $*.pbm > $*.slx
+
+.pbm.hc:
+	./foo2hiperc < $*.pbm > $*.hc
+
+.pbm.hbpl:
+	./foo2hbpl2 < $*.pbm > $*.hbpl
+
+#
+# The usual build rules
+#
+all:	all-test $(PROGS) $(BINPROGS) $(SHELLS) getweb \
+	all-icc2ps all-osx-hotplug man doc \
+	all-done
+
+all-test:
+	#
+	# Dependencies...
+	#
+	@if ! type $(CC) >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: $(CC) is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install Software Development (gcc) package"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	@if ! test -f /usr/include/stdio.h; then \
+	    echo "      ***"; \
+	    echo "      *** Error: /usr/include/stdio.h is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install Software Development (gcc) package"; \
+	    echo "      *** for Ubuntu: sudo apt-get install build-essential"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	@if ! type gs >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: gs is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install ghostscript (gs) package"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	@if ! type dc >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: dc is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install dc package"; \
+	    echo "      *** for Ubuntu: sudo apt-get install dc"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	@if ! dc -V >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: must install GNU dc with the -e option!"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+ifeq ($(UNAME),Darwin)
+	@if ! type gsed >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: gsed is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** For OSX: sudo port install gsed"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+endif
+	# ... OK!
+	#
+
+all-done:
+	@echo
+	@echo "It is possible that certain products which can be built using this"
+	@echo "software module might form inventions protected by patent rights in"
+	@echo "some countries (e.g., by patents about arithmetic coding algorithms"
+	@echo "owned by IBM and AT&T in the USA). Provision of this software by the"
+	@echo "author does NOT include any licences for any patents. In those"
+	@echo "countries where a patent licence is required for certain applications"
+	@echo "of this software module, you will have to obtain such a licence"
+	@echo "yourself."
+
+
+foo2zjs: foo2zjs.o
+	$(CC) $(CFLAGS) -o $@ foo2zjs.o $(LIBJBG)
+
+foo2hp: foo2hp.o
+	# $(CC) $(CFLAGS) -o $@ foo2hp.o $(LIBJBG) /usr/local/lib/libdmalloc.a
+	$(CC) $(CFLAGS) -o $@ foo2hp.o $(LIBJBG)
+
+foo2xqx: foo2xqx.o 
+	$(CC) $(CFLAGS) -o $@ foo2xqx.o $(LIBJBG)
+
+foo2lava: foo2lava.o 
+	$(CC) $(CFLAGS) -o $@ foo2lava.o $(LIBJBG)
+
+foo2qpdl: foo2qpdl.o 
+	$(CC) $(CFLAGS) -o $@ foo2qpdl.o $(LIBJBG)
+
+foo2oak: foo2oak.o 
+	$(CC) $(CFLAGS) -o $@ foo2oak.o $(LIBJBG)
+
+foo2slx: foo2slx.o 
+	$(CC) $(CFLAGS) -o $@ foo2slx.o $(LIBJBG)
+
+foo2hiperc: foo2hiperc.o 
+	$(CC) $(CFLAGS) -o $@ foo2hiperc.o $(LIBJBG)
+
+foo2hbpl2: foo2hbpl2.o 
+	$(CC) $(CFLAGS) -o $@ foo2hbpl2.o $(LIBJBG)
+
+
+foo2zjs-wrapper: foo2zjs-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2hp2600-wrapper: foo2hp2600-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2xqx-wrapper: foo2xqx-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2lava-wrapper: foo2lava-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2qpdl-wrapper: foo2qpdl-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2oak-wrapper: foo2oak-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2slx-wrapper: foo2slx-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2hiperc-wrapper: foo2hiperc-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2hbpl2-wrapper: foo2hbpl2-wrapper.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+foo2zjs-wrapper9: foo2zjs-wrapper9.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+
+getweb: getweb.in Makefile
+	[ ! -f $@ ] || chmod +w $@
+	sed < $@.in > $@ \
+	    -e "s@\$${URLZJS}@$(URLZJS)@" \
+	    -e 's@^PREFIX=.*@PREFIX=$(PREFIX)@' || (rm -f $@ && exit 1)
+	chmod 555 $@
+
+all-icc2ps:
+	cd icc2ps; $(MAKE) all
+
+all-osx-hotplug:
+ifeq ($(UNAME),Darwin)
+	cd osx-hotplug; $(MAKE) all
+endif
+
+ok: ok.o 
+	$(CC) $(CFLAGS) ok.o $(LIBJBG) -o $@
+
+gipddecode: gipddecode.o 
+	$(CC) $(CFLAGS) gipddecode.o $(LIBJBG) -o $@
+
+hbpldecode: hbpldecode.o
+	$(CC) $(CFLAGS) hbpldecode.o $(LIBJBG) -o $@
+
+hipercdecode: hipercdecode.o 
+	$(CC) $(CFLAGS) hipercdecode.o $(LIBJBG) -o $@
+
+lavadecode: lavadecode.o 
+	$(CC) $(CFLAGS) lavadecode.o $(LIBJBG) -o $@
+
+oakdecode: oakdecode.o 
+	$(CC) $(CFLAGS) -g oakdecode.o $(LIBJBG) -o $@
+
+opldecode: opldecode.o 
+	$(CC) $(CFLAGS) -g opldecode.o $(LIBJBG) -o $@
+
+qpdldecode: qpdldecode.o 
+	$(CC) $(CFLAGS) qpdldecode.o $(LIBJBG) -o $@
+
+splcdecode: splcdecode.o 
+	$(CC) $(CFLAGS) splcdecode.o $(LIBJBG) -lz -o $@
+
+slxdecode: slxdecode.o
+	$(CC) $(CFLAGS) slxdecode.o $(LIBJBG) -o $@
+
+xqxdecode: xqxdecode.o 
+	$(CC) $(CFLAGS) xqxdecode.o $(LIBJBG) -o $@
+
+zjsdecode: zjsdecode.o
+	$(CC) $(CFLAGS) zjsdecode.o $(LIBJBG) -o $@
+
+command2foo2lava-pjl: command2foo2lava-pjl.o
+	$(CC) $(CFLAGS) -L/usr/local/lib command2foo2lava-pjl.o -lcups -o $@
+
+command2foo2lava-pjl.o: command2foo2lava-pjl.c
+	$(CC) $(CFLAGS) -I/usr/local/include -c command2foo2lava-pjl.c
+
+#
+# Installation rules
+#
+install: all install-test install-prog install-icc2ps install-osx-hotplug \
+	    install-extra install-crd install-foo install-ppd \
+	    install-gui install-desktop install-filter \
+	    install-man install-doc
+	#
+	# If you use CUPS, then restart the spooler:
+	#	make cups
+	#
+	# Now use your printer configuration GUI to create a new printer.
+	#
+	# On Redhat 7.2/7.3/8.0/9.0 and Fedora Core 1-5, run "printconf-gui".
+	# On Fedora 6/7/8/9/10/11/12, run "system-config-printer".
+	# On Mandrake, run "printerdrake"
+	# On Suse 9.x/10.x/11.x, run "yast"
+	# On Ubuntu 5.10/6.06/6.10/7.04, run "gnome-cups-manager"
+	# On Ubuntu 7.10/8.x/9.x, run "system-config-printer".
+
+install-test:
+	#
+	# Installation Dependencies...
+	#
+	@if [ -f /usr/local/libexec/cups/filter/foomatic-rip ]; then \
+	    : ; \
+	elif [ -f /usr/lib/cups/filter/foomatic-rip ]; then \
+	    : ; \
+	elif [ -f /usr/lib/lp/bin/foomatic-rip ]; then \
+	    : ; \
+	elif ! type foomatic-rip >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: foomatic-rip is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install foomatic package(s) for your OS"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	# ... OK!
+	#
+    
+
+UDEVBIN=$(DESTDIR)/bin/
+
+install-prog:
+	#
+	# Install driver, wrapper, and development tools
+	#
+	$(INSTALL) -d $(BIN)
+	$(INSTALL) -c $(PROGS) $(SHELLS) $(BIN)/
+	if [ "$(BINPROGS)" != "" ]; then \
+	    $(INSTALL) -d $(UDEVBIN); \
+	    $(INSTALL) -c $(BINPROGS) $(UDEVBIN); \
+	fi
+	#
+	# Install gamma correction files.  These are just templates,
+	# and don't actually do anything right now.  If anybody wants
+	# to tune them or point me at a process for doing that, please...
+	#
+	$(INSTALL) -d $(SHAREZJS)/
+	$(INSTALL) -c -m 644 gamma.ps $(SHAREZJS)/
+	$(INSTALL) -c -m 644 gamma-lookup.ps $(SHAREZJS)/
+	$(INSTALL) -d $(SHAREOAK)/
+	$(INSTALL) -d $(SHAREHP)/
+	$(INSTALL) -d $(SHAREXQX)/
+	$(INSTALL) -d $(SHARELAVA)/
+	$(INSTALL) -d $(SHAREHC)/
+
+install-foo:
+	#
+	# Remove obsolete foomatic database files from previous versions
+	#
+	rm -f $(FOODB)/opt/foo2zjs-Media.xml
+	rm -f $(FOODB)/opt/foo2zjs-PaperSize.xml
+	rm -f $(FOODB)/opt/foo2zjs-Source.xml
+	rm -f $(FOODB)/opt/foo2zjs-DitherPPI.xml
+	rm -f $(FOODB)/opt/foo2zjs-Copies.xml
+	rm -f $(FOODB)/opt/foo2zjs-Nup.xml
+	rm -f $(FOODB)/opt/foo2zjs-NupOrient.xml
+	rm -f $(FOODB)/opt/foo2*-Quality.xml
+	rm -f $(FOODB)/printer/KonicaMinolta*.xml
+	#
+	# Install current database files
+	#
+	@if [ -d $(FOODB) ]; then \
+	    for dir in driver printer opt; do \
+		echo install -d $(FOODB)/$$dir/; \
+		$(INSTALL) -d $(FOODB)/$$dir/; \
+		echo install -m 644 foomatic-db/$$dir/*.xml $(FOODB)/$$dir/; \
+		$(INSTALL) -c -m 644 foomatic-db/$$dir/*.xml $(FOODB)/$$dir/; \
+	    done \
+	else \
+	    echo "***"; \
+	    echo "*** WARNING! You don't have directory $(FOODB)/"; \
+	    echo "*** If you want support for foomatic printer configuration,";\
+	    echo "*** then you will have to manually install these files..."; \
+	    echo "***"; \
+	    ls foomatic-db/*/*.xml | sed 's/^/	/'; \
+	    echo "***"; \
+	    echo "*** ... wherever foomatic is stashed on your machine."; \
+	    echo "***"; \
+	fi
+	#
+	# Clear foomatic cache and rebuild database if needed
+	#
+	rm -rf /var/cache/foomatic/*/*
+	rm -f /var/cache/foomatic/printconf.pickle
+	if [ -d /var/cache/foomatic/compiled ]; then \
+	    cd /var/cache/foomatic/compiled; \
+	    foomatic-combo-xml -O >overview.xml; \
+	fi
+
+install-icc2ps:
+	#
+	# Install ICM to Postscript file conversion utility
+	#
+	cd icc2ps; $(MAKE) PREFIX=$(PREFIX) install
+
+install-osx-hotplug:
+ifeq ($(UNAME),Darwin)
+	#
+	# Install Mac OSX hotplug utility
+	#
+	cd osx-hotplug; $(MAKE) PREFIX=$(PREFIX) install
+endif
+
+install-crd:
+	#
+	# Install prebuilt CRD files (from m2300w project)
+	#
+	$(INSTALL) -d $(SHAREZJS)/
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREZJS)/crd/
+	for i in crd/zjs/*.*; do \
+	    $(INSTALL) -c -m 644 $$i $(SHAREZJS)/crd/; \
+	done
+	#
+	# Install prebuilt CRD files for CLP-300/CLP-600
+	#
+	$(INSTALL) -d $(SHAREQPDL)/
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREQPDL)/crd/
+	for i in crd/qpdl/*cms* crd/qpdl/*.ps; do \
+	    $(INSTALL) -c -m 644 $$i $(SHAREQPDL)/crd/; \
+	done
+
+install-psfiles:
+	#
+	# Install prebuilt psfiles files (from m2300w project)
+	#
+	$(INSTALL) -d $(SHAREHP)/
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREHP)/psfiles/
+	for i in psfiles/*.*; do \
+	    $(INSTALL) -c -m 644 $$i $(SHAREHP)/psfiles/; \
+	done
+
+install-extra:
+	#
+	# Install extra files (ICM and firmware), if any exist here.
+	#
+	# Get files from the printer manufacturer, i.e. www.minolta-qms.com,
+	# or use the "./getweb" convenience script.
+	#
+	$(INSTALL) -d $(SHAREZJS)/
+	# foo2zjs ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREZJS)/icm/
+	for i in DL*.icm CP*.icm km2430*.icm hp-cp1025*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREZJS)/icm/; \
+	    fi; \
+	done
+	# foo2zjs Firmware files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREZJS)/firmware/
+	for i in sihp1*.img; do \
+	    if [ -f $$i ]; then \
+		base=`basename $$i .img`; \
+		./arm2hpdl $$i >$$base.dl; \
+		$(INSTALL) -c -m 644 $$base.dl $(SHAREZJS)/firmware/; \
+	    fi; \
+	done
+	# foo2xqx Firmware files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREXQX)/firmware/
+	for i in sihpP*.img; do \
+	    if [ -f $$i ]; then \
+		base=`basename $$i .img`; \
+		./arm2hpdl $$i >$$base.dl; \
+		$(INSTALL) -c -m 644 $$base.dl $(SHAREXQX)/firmware/; \
+	    fi; \
+	done
+	# foo2oak ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREOAK)/icm/
+	for i in hpclj2[56]*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREOAK)/icm/; \
+	    fi; \
+	done
+	# foo2hp ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREHP)/icm/
+	for i in hpclj26*.icm km2430*.icm hp1215*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREHP)/icm/; \
+	    fi; \
+	done
+	# foo2lava ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHARELAVA)/icm/
+	for i in km-1600*.icm km2530*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHARELAVA)/icm/; \
+	    fi; \
+	done
+	# foo2qpdl ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREQPDL)/icm/
+	for i in samclp*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREQPDL)/icm/; \
+	    fi; \
+	done
+	# foo2slx ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHARESLX)/icm/
+	for i in lex*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHARESLX)/icm/; \
+	    fi; \
+	done
+	# foo2hiperc ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREHC)/icm/
+	for i in OK*.icm C3400*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREHC)/icm/; \
+	    fi; \
+	done
+	# foo2hbpl ICM files (if any)
+	$(INSTALL) $(LPuid) $(LPgid) -m 775 -d $(SHAREHBPL)/icm/
+	for i in hbpl*.icm; do \
+	    if [ -f $$i ]; then \
+		$(INSTALL) -c -m 644 $$i $(SHAREHBPL)/icm/; \
+	    fi; \
+	done
+
+MODEL=$(DESTDIR)/usr/share/cups/model
+LOCALMODEL=$(DESTDIR)/usr/local/share/cups/model
+MACMODEL=/Library/Printers/PPDs/Contents/Resources
+PPD=$(DESTDIR)/usr/share/ppd
+VARPPD=/var/lp/ppd
+install-ppd:
+	#
+	# Install PPD files for CUPS
+	#
+	export PATH=$$PATH:`pwd`:; \
+	if [ -x /usr/sbin/ppdmgr -a -s $(VARPPD)/ppdcache ]; then \
+	    $(INSTALL) $(LPgid) -d $(VARPPD)/user; \
+	    cd PPD; \
+	    for ppd in *.ppd; do \
+		manuf=`echo "$$ppd" | sed 's/-.*//'`; \
+		$(INSTALL) $(LPgid) -d $(VARPPD)/user/$$manuf; \
+		modify-ppd <$$ppd | gzip > $(VARPPD)/user/$$manuf/$$ppd.gz; \
+		chmod 664 $(VARPPD)/user/$$manuf/$$ppd.gz; \
+	    done; \
+	    ppdmgr -u; \
+	elif [ -d $(PPD) ]; then \
+	    find $(PPD) -name '*foo2zjs*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2hp*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2xqx*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2lava*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2qpdl*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2slx*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2hiperc*' | xargs rm -rf; \
+	    find $(PPD) -name '*foo2hbpl*' | xargs rm -rf; \
+	    [ -d $(PPD)/foo2zjs ] || mkdir $(PPD)/foo2zjs; \
+	    cd PPD; \
+	    for ppd in *.ppd; do \
+		modify-ppd <$$ppd | gzip > $(PPD)/foo2zjs/$$ppd.gz; \
+		chmod 664 $(PPD)/foo2zjs/$$ppd.gz; \
+	    done; \
+	fi
+	#
+	export PATH=$$PATH:`pwd`:; \
+	if [ -d $(MODEL) ]; then \
+	    rm -f $(MODEL)/KonicaMinolta*; \
+	    cd PPD; \
+	    for ppd in *.ppd; do \
+		modify-ppd <$$ppd | gzip > $(MODEL)/$$ppd.gz; \
+		chmod 664 $(MODEL)/$$ppd.gz; \
+	    done; \
+	elif [ -d $(LOCALMODEL) ]; then \
+	    rm -f $(LOCALMODEL)/KonicaMinolta*; \
+	    cd PPD; \
+	    for ppd in *.ppd; do \
+		modify-ppd <$$ppd | gzip > $(LOCALMODEL)/$$ppd.gz; \
+		chmod 664 $(LOCALMODEL)/$$ppd.gz; \
+	    done; \
+	elif [ -d $(MACMODEL) ]; then \
+	    rm -f $(MACMODEL)/KonicaMinolta*; \
+	    cd PPD; \
+	    for ppd in *.ppd; do \
+		modify-ppd <$$ppd | gzip > $(MACMODEL)/$$ppd.gz; \
+		chmod 664 $(MACMODEL)/$$ppd.gz; \
+	    done; \
+	fi
+
+APPL=/usr/share/applications
+OLDAPPL=/usr/share/gnome/apps/System
+PIXMAPS=/usr/share/pixmaps
+
+install-desktop:
+	#
+	# Install GNOME desktop
+	#
+	if [ -d $(APPL) ]; then \
+	    $(INSTALL) -c -m 644 hplj1020.desktop $(APPL); \
+	fi
+	if [ -d $(OLDAPPL) ]; then \
+	    $(INSTALL) -c -m 644 hplj1020.desktop $(OLDAPPL); \
+	fi
+	if [ -d $(PIXMAPS) ]; then \
+	    $(INSTALL) -c -m 644 hplj1020_icon.png $(PIXMAPS); \
+	fi
+
+install-gui:
+	#
+	# Install GUI
+	#
+	$(INSTALL) -c -m 644 hplj1020_icon.gif $(SHAREZJS)
+	$(INSTALL) -c -m 755 hplj10xx_gui.tcl $(SHAREZJS)
+	
+
+USBDIR=/etc/hotplug/usb
+UDEVDIR=/etc/udev/rules.d
+LIBUDEVDIR=/lib/udev/rules.d
+RULES=hplj10xx.rules
+#UDEVD=/sbin/udevd
+# For FreeBSD 8.0
+DEVDDIR=/etc/devd
+
+ifeq ($(UNAME),Darwin)
+install-hotplug: install-hotplug-test install-hotplug-osx
+else
+install-hotplug: install-hotplug-test install-hotplug-prog
+endif
+
+install-hotplug-test:
+	#
+	# Hotplug Installation Dependencies...
+	#
+	@if ! type ex >/dev/null 2>&1; then \
+	    echo "      ***"; \
+	    echo "      *** Error: "ex" is not installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Install "vim" package(s) for your OS"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	@if test -r $(LIBUDEVDIR)/*-printers.rules; then \
+	    echo "      ***"; \
+	    echo "      *** Error: system-config-printer-udev is installed!"; \
+	    echo "      ***"; \
+	    echo "      *** Remove it with: (Fedora)"; \
+	    echo "      *** 	# yum remove system-config-printer-udev"; \
+	    echo "      *** OR"; \
+	    echo "      *** 	# rpm -e --nodeps system-config-printer-udev"; \
+	    echo "      *** OR (Ubuntu, Debian)"; \
+	    echo "      *** 	$$ sudo apt-get remove system-config-printer-udev"; \
+	    echo "      *** OR (generic linux)"; \
+	    echo "      ***	# rm -f $(LIBUDEVDIR)/*-printers.rules"; \
+	    echo "      ***"; \
+	    exit 1; \
+	fi
+	# ... OK!
+	#
+
+install-hotplug-prog:
+	#
+	#	remove HPLIP (proprietary) files and install our version
+	#
+	if [ -d $(UDEVDIR) ]; then \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_1000*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_1005*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_1018*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_1020*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_p1005*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_p1006*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_p1007*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_p1008*; \
+	    rm -f $(UDEVDIR)/*hpmud*laserjet_p1505*; \
+	    rm -f $(UDEVDIR)/*hpmud_support.rules; \
+	    rm -f $(UDEVDIR)/*hpmud_plugin.rules; \
+	    rm -f $(LIBUDEVDIR)/*hpmud_support.rules; \
+	    rm -f $(LIBUDEVDIR)/*hpmud_plugin.rules; \
+	    rm -f $(LIBUDEVDIR)/*-hplj10xx.rules; \
+	    if [ -x /sbin/udevd ]; then \
+		version=`/sbin/udevd --version 2>/dev/null`; \
+	    elif [ -x /usr/lib/udev/udevd ]; then \
+		version=`/usr/lib/udev/udevd --version 2>/dev/null`; \
+	    elif [ -x /usr/lib/systemd/systemd-udevd ]; then \
+		version=`/usr/lib/systemd/systemd-udevd --version 2>/dev/null`; \
+	    fi; \
+	    if [ "$$version" = "" ]; then version=0; fi; \
+	    echo "*** udev version $$version"; \
+	    if [ "$$version" -lt 148 ]; then \
+		$(INSTALL) -c -m 644 $(RULES).old $(UDEVDIR)/11-$(RULES); \
+	    else \
+		$(INSTALL) -c -m 644 $(RULES) $(UDEVDIR)/11-$(RULES); \
+	    fi \
+	fi
+	if [ -d $(DEVDDIR) ]; then \
+	    $(INSTALL) -c -m 644 hplj10xx.conf $(DEVDDIR)/; \
+	fi
+	[ -d $(USBDIR) ] || $(INSTALL) -d -m 755 $(USBDIR)/
+	$(INSTALL) -c -m 755 hplj1000 $(USBDIR)/
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hplj1005
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hplj1018
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hplj1020
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hpljP1005
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hpljP1006
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hpljP1007
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hpljP1008
+	ln -sf $(USBDIR)/hplj1000 $(USBDIR)/hpljP1505
+	$(USBDIR)/hplj1000 install-usermap
+	$(USBDIR)/hplj1005 install-usermap
+	$(USBDIR)/hplj1018 install-usermap
+	$(USBDIR)/hplj1020 install-usermap
+	$(USBDIR)/hpljP1005 install-usermap
+	$(USBDIR)/hpljP1006 install-usermap
+	$(USBDIR)/hpljP1007 install-usermap
+	$(USBDIR)/hpljP1008 install-usermap
+	$(USBDIR)/hpljP1505 install-usermap
+	# modprobe usblp
+	$(USBDIR)/hplj1000 install-usblp
+
+install-hotplug-osx:
+	cd osx-hotplug; $(MAKE) PREFIX=$(PREFIX) install-hotplug
+
+install-filter:
+	if [ "$(CUPS_SERVERBIN)" != "" ]; then \
+	    ln -sf $(BIN)/command2foo2lava-pjl $(CUPS_SERVERBIN)/filter/; \
+	fi
+
+CUPSDCONF=/etc/cups/cupsd.conf
+MACLOAD=/System/Library/LaunchDaemons/org.cups.cupsd.plist
+
+cups:	FRC
+	if [ -r $(CUPSDCONF) ]; then \
+	    (	echo "g/^FileDev/d"; \
+		echo "g/ foo2zjs.../d"; \
+		echo '$$a'; \
+		echo "# 'FileDevice Yes' line installed by foo2zjs..."; \
+		echo "FileDevice Yes"; \
+		echo "."; \
+		echo "w"; \
+	    ) | ex $(CUPSDCONF); \
+	fi
+	if [ -x /etc/init.d/cups ]; then \
+	    /etc/init.d/cups restart; \
+	    if [ $$? != 0 ]; then \
+		service cups restart; \
+	    fi \
+	elif [ -x /etc/rc.d/rc.cups ]; then \
+	    /etc/rc.d/rc.cups restart; \
+	elif [ -x /etc/init.d/cupsys ]; then \
+	    /etc/init.d/cupsys restart; \
+	elif [ -x /etc/init.d/cupsd ]; then \
+	    /etc/init.d/cupsd restart; \
+	elif [ -x /usr/local/etc/rc.d/cups.sh ]; then \
+	    /usr/local/etc/rc.d/cups.sh restart; \
+	elif [ -x /usr/local/etc/rc.d/cups.sh.sample ]; then \
+	    cp /usr/local/etc/rc.d/cups.sh.sample /usr/local/etc/rc.d/cups.sh; \
+	    /usr/local/etc/rc.d/cups.sh restart; \
+	elif [ -x /bin/systemctl ]; then \
+	    systemctl restart cups.service; \
+	elif [ -x /bin/launchctl ]; then \
+	    /bin/launchctl unload $(MACLOAD); \
+	    /bin/launchctl load $(MACLOAD); \
+	fi
+
+#
+# Uninstall
+#
+uninstall:
+	cd osx-hotplug; $(MAKE) PREFIX=$(PREFIX) uninstall
+	-rm -f /etc/hotplug/usb/hplj1000
+	-rm -f /etc/hotplug/usb/hplj1005
+	-rm -f /etc/hotplug/usb/hplj1018
+	-rm -f /etc/hotplug/usb/hplj1020
+	-rm -f /etc/hotplug/usb/foo2zjs.usermap
+	-(echo "g/^hplj10[02][05]/d"; echo "w") | ex /etc/hotplug/usb.usermap
+	-rm -f /etc/udev/rules.d/11-hplj10xx.rules
+	-rm -f /usr/bin/usb_printerid /bin/usb_printerid /sbin/usb_printerid
+	-rm -f /etc/hotplug/usb/hplj.usermap #
+	-rm -f /etc/udev/rules.d/58-foo2zjs.rules #
+	-rm -f /sbin/foo2zjs-loadfw #
+	-rm -rf /usr/share/doc/foo2zjs/
+	-rm -f $(MANDIR)/man1/foo2zjs*.1 $(MANDIR)/man1/zjsdecode.1
+	-rm -f $(MANDIR)/man1/foo2hp*.1
+	-rm -f $(MANDIR)/man1/foo2oak*.1 $(MANDIR)/man1/oakdecode.1
+	-rm -f $(MANDIR)/man1/foo2lava*.1 $(MANDIR)/man1/lavadecode.1
+	-rm -f $(MANDIR)/man1/foo2qpdl*.1 $(MANDIR)/man1/qpdldecode.1
+	-rm -f $(MANDIR)/man1/foo2slx*.1 $(MANDIR)/man1/slxdecode.1
+	-rm -f $(MANDIR)/man1/foo2xqx*.1 $(MANDIR)/man1/xqxdecode.1
+	-rm -f $(MANDIR)/man1/opldecode.1 $(MANDIR)/man1/rodecode.1
+	-rm -f $(MANDIR)/man1/foo2hiperc*.1 $(MANDIR)/man1/hipercdecode.1
+	-rm -f $(MANDIR)/man1/foo2hbpl*.1 $(MANDIR)/man1/hbpldecode.1
+	-rm -f $(MANDIR)/man1/gipddecode.1
+	-rm -f $(MANDIR)/man1/arm2hpdl.1 $(MANDIR)/man1/usb_printerid.1
+	-rm -f $(MANDIR)/man1/foo2zjs-icc2ps.1
+	-rm -rf /usr/share/foo2zjs/
+	-rm -rf /usr/share/foo2hp/
+	-rm -rf /usr/share/foo2oak/
+	-rm -rf /usr/share/foo2xqx/
+	-rm -rf /usr/share/foo2lava/
+	-rm -rf /usr/share/foo2qpdl/
+	-rm -rf /usr/share/foo2slx/
+	-rm -rf /usr/share/foo2hiperc/
+	-rm -rf /usr/share/foo2hbpl/
+	-rm -f /usr/bin/arm2hpdl
+	-rm -f /usr/bin/foo2zjs-wrapper /usr/bin/foo2zjs /usr/bin/zjsdecode
+	-rm -f /usr/bin/foo2oak-wrapper /usr/bin/foo2oak /usr/bin/oakdecode
+	-rm -f /usr/bin/foo2hp2600-wrapper /usr/bin/foo2hp
+	-rm -f /usr/bin/foo2xqx-wrapper /usr/bin/foo2xqx /usr/bin/xqxdecode
+	-rm -f /usr/bin/foo2lava-wrapper /usr/bin/foo2lava /usr/bin/lavadecode
+	-rm -f /usr/bin/foo2qpdl-wrapper /usr/bin/foo2qpdl /usr/bin/qpdldecode
+	-rm -f /usr/bin/foo2slx-wrapper /usr/bin/foo2slx /usr/bin/slxdecode
+	-rm -f /usr/bin/foo2hiperc-wrapper /usr/bin/foo2hiperc
+	-rm -f /usr/bin/foo2hbpl2-wrapper /usr/bin/foo2hbpl2
+	-rm -f /usr/bin/hipercdecode
+	-rm -f /usr/bin/gipddecode
+	-rm -f /usr/bin/hbpldecode
+	-rm -f /usr/bin/opldecode
+	-rm -f /usr/bin/rodecode
+	-rm -f /usr/bin/foo2zjs-icc2ps
+	-rm -f /usr/bin/foo2zjs-pstops
+	-rm -f /usr/bin/command2foo2lava-pjl
+	-rm -f /usr/lib/cups/filter/command2foo2lava-pjl
+	-rm -f /usr/share/applications/hplj1020.desktop
+	-rm -f /usr/share/pixmaps/hplj1020_icon.png
+	-cd foomatic-db; for i in `find driver opt printer -name "*.xml"`; do \
+		rm -f $(FOODB)/$$i; \
+	done
+	cd PPD; for ppd in *.ppd; do \
+	    rm -f $(MODEL)/$$ppd.gz; \
+	done;
+	-rm -f /var/cache/foomatic/printconf.pickle
+
+#
+# Clean
+#
+clean:
+	-rm -f $(PROGS) $(BINPROGS) $(SHELLS)
+	-rm -f *.zc *.zm
+	-rm -f xxx.* xxxomatic
+	-rm -f foo2zjs.o zjsdecode.o foo2hp.o
+	-rm -f foo2oak.o oakdecode.o
+	-rm -f foo2xqx.o xqxdecode.o
+	-rm -f foo2lava.o lavadecode.o
+	-rm -f foo2qpdl.o qpdldecode.o
+	-rm -f foo2slx.o slxdecode.o
+	-rm -f foo2hiperc.o hipercdecode.o
+	-rm -f foo2hbpl2.o hbpldecode.o
+	-rm -f opldecode.o gipddecode.o
+	-rm -f command2foo2lava-pjl.o
+	-rm -f foo2oak.html foo2zjs.html foo2hp.html foo2xqx.html foo2lava.html
+	-rm -f foo2slx.html foo2qpdl.html foo2hiperc.html foo2hbpl.html
+	-rm -f index.html
+	-rm -f arch*.gif
+	-rm -f sihp*.dl
+	-rm -f *.tar.gz
+	-rm -f getweb
+	-rm -f patch.db
+	-rm -f $(MANPAGES) manual.pdf
+	-rm -f *.zjs *.zm *.zc *.zc? *.zc?? *.oak *.pbm *.pksm *.cmyk
+	-rm -f pksm2bitcmyk
+	-rm -f *.icm.*.ps
+	cd icc2ps; $(MAKE) $@
+	cd osx-hotplug; $(MAKE) $@
+
+#
+# Header dependencies
+#
+zjsdecode.o: zjs.h
+foo2zjs.o: zjs.h
+foo2oak.o: oak.h
+jbig.o: 
+foo2hp.o:  zjs.h cups.h
+foo2xqx.o:  xqx.h
+foo2lava.o:
+foo2qpdl.o: qpdl.h
+foo2slx.o: slx.h
+foo2hiperc.o: hiperc.h
+foo2hbpl2.o: hbpl.h
+hipercdecode.o: hiperc.h
+hbpldecode.o: 
+lavadecode.o: 
+qpdldecode.o: 
+opldecode.o: 
+slxdecode.o: slx.h 
+xqxdecode.o: xqx.h 
+gipddecode.o: slx.h 
+
+#
+# foo2* Regression tests
+#
+test:		testzjs testhp
+	@ls -l *.z* #*.oak
+	#
+	# All regression tests passed.
+	#
+	# Send the appropriate test page .zm/.zc ZjStream file(s) to
+	# your printer using a *RAW* printer queue.
+
+#
+# foo2zjs Regression tests
+#
+testzjs:	testpage.zm \
+		testpage.zc10 \
+		lj1000.zm lj1020.zm
+# testpage.zc1 testpage.zc2 testpage.zc3 \
+
+testpage.zm: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	#
+	# Tests will pass only if you are using ghostscript-8.71-16.fc14
+	#
+	# Monochrome test page for Minolta 2200/2300 DL
+	PATH=.:$$PATH time -p foo2zjs-wrapper testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+testpage.zc10: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	#
+	# Color test page for Minolta 2200/2300 DL
+	PATH=.:$$PATH time -p foo2zjs-wrapper -c -C10 testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+testpage.zc1: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	PATH=.:$$PATH time -p foo2zjs-wrapper -c -C1 testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+testpage.zc2: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	PATH=.:$$PATH time -p foo2zjs-wrapper -c -C2 testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+testpage.zc3: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	PATH=.:$$PATH time -p foo2zjs-wrapper -c -C3 testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+lj1000.zm: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	#
+	# Monochrome test page for HP LJ1000
+	PATH=.:$$PATH time -p foo2zjs-wrapper -r600x600 -P testpage.ps >$@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+lj1020.zm: testpage.ps foo2zjs-wrapper foo2zjs Makefile FRC
+	#
+	# Monochrome test page for HP LJ1020
+	PATH=.:$$PATH time -p foo2zjs-wrapper -r600x600 -P -z1 \
+	    testpage.ps | sed "/JOBATTR/d" >$@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+#
+# foo2hp Regression tests
+#
+testhp: lj2600.zm1 lj2600.zc1
+
+lj2600.zm1: testpage.ps foo2hp2600-wrapper foo2hp Makefile FRC
+	#
+	# Monochrome test page for HP 2600n (1-bit)
+	PATH=.:$$PATH time -p foo2hp2600-wrapper testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+lj2600.zc1: testpage.ps foo2hp2600-wrapper foo2hp Makefile FRC
+	#
+	# Color test page for HP 2600n (1-bit)
+	PATH=.:$$PATH time -p foo2hp2600-wrapper -c testpage.ps > $@
+	@got=`md5sum $@`; grep -q "$$got" regress.txt || \
+	    { echo "*** Test failure, got $$got"; ls -l $@; exit 1; }
+
+#
+# foo2oak Regression tests
+#
+testoak: pprtest-0.oak pprtest-1.oak pprtest-2.oak pprtest-3.oak
+
+pprtest-0.oak: FRC
+	#
+	# 1-bit Monochrome test page for OAKT
+	PATH=.:$$PATH foo2oak-wrapper -b1 -D12345678 pprtest.ps > $@
+	@want="fbd4c1a560985a6ad47ff23b018c7ce8  $@"; got=`md5sum $@`; \
+	[ "$$want" = "$$got" ] || \
+	    { echo "*** Test failure, got $$got"; exit 1; }
+
+pprtest-1.oak: FRC
+	#
+	# 2-bit Monochrome test page for OAKT
+	PATH=.:$$PATH foo2oak-wrapper -b2 -D12345678 pprtest.ps > $@
+	@want="bec9a24ee1ce0d388b773f83609a4d01  $@"; got=`md5sum $@`; \
+	[ "$$want" = "$$got" ] || \
+	    { echo "*** Test failure, got $$got"; exit 1; }
+
+pprtest-2.oak: FRC
+	#
+	# 1-bit color test page for OAKT
+	PATH=.:$$PATH foo2oak-wrapper -c -b1 -D12345678 pprtest.ps > $@
+	@want="c714bcd69fe5f3b2b257d7435eb938d1  $@"; got=`md5sum $@`; \
+	[ "$$want" = "$$got" ] || \
+	    { echo "*** Test failure, got $$got"; exit 1; }
+
+pprtest-3.oak: FRC
+	#
+	# 2-bit color test page for OAKT
+	PATH=.:$$PATH foo2oak-wrapper -c -b2 -D12345678 pprtest.ps > $@
+	@want="ed89abcd873979bc9337e02263511964  $@"; got=`md5sum $@`; \
+	[ "$$want" = "$$got" ] || \
+	    { echo "*** Test failure, got $$got"; exit 1; }
+
+#
+#	icc2ps regression tests
+#
+ICC2PS=./icc2ps/foo2zjs-icc2ps
+icctest:
+	for g in *.icm; do \
+	    for i in 0 1 2 3; do \
+		$(ICC2PS) -o $$g -t$$i \
+		| sed '/Created:/d' > $$g.$$i.ps; \
+	    done; \
+	done
+
+
+#
+# Make phony print devices for testing full spooler interface without printing
+#
+tmpdev:
+	DEV=/tmp/OAK; > $$DEV; chmod 666 $$DEV
+	DEV=/tmp/OAKCM; > $$DEV; chmod 666 $$DEV
+	DEV=/tmp/testfile; > $$DEV; chmod 666 $$DEV
+
+#
+# Test files for debugging
+#
+testpage.pbm: testpage.ps Makefile
+xxx.zc: FRC
+xxx.zm: FRC
+
+#
+#	PPD files
+#	
+#	Don't edit the PPD files.  Instead, change the
+#	foomatic/{device,printer,opt}/*.xml files or the "modify-ppd" script.
+#
+FOOPRINT=*.xml
+ppd:
+	#
+	# Generate PPD files using local tools
+	#
+	[ -d PPD ] || mkdir PPD
+	> foomatic-db/oldprinterids
+	cd foomatic-db; rm -f db; ln -sf . db
+	cd foomatic-db; rm -f source; ln -sf . source
+	for i in foomatic-db/printer/$(FOOPRINT); \
+	do \
+	    printer=`basename $$i .xml`; \
+	    case "$$printer" in \
+	    *"d-Color_P160"*)   driver=foo2hiperc;; \
+	    *M1005*|*M1120*)    driver=foo2xqx;; \
+	    *P1[05]0[5678]*)    driver=foo2xqx;; \
+	    *P2014*)            driver=foo2xqx;; \
+	    *1500*|*OAKT*)      driver=foo2oak;; \
+	    *1018*|*102[02]*)	driver=foo2zjs-z1;; \
+	    *P2035*)		driver=foo2zjs-z1;; \
+	    *1319*)		driver=foo2zjs-z1;; \
+	    *P110*)		driver=foo2zjs-z2;; \
+	    *P156*)		driver=foo2zjs-z2;; \
+	    *P160*)		driver=foo2zjs-z2;; \
+	    *CP102*)		driver=foo2zjs-z3;; \
+	    *1635*|*2035*)      driver=foo2oak-z1;; \
+	    *1600W|*16[89]0*)   driver=foo2lava;; \
+	    *4690*)		driver=foo2lava;; \
+	    *2530*|*24[89]0*)   driver=foo2lava;; \
+	    *6115*)             driver=foo2lava;; \
+	    *C110*)             driver=foo2lava;; \
+	    *6121*)             driver=foo2lava;; \
+	    *1600*|*2600*)      driver=foo2hp;; \
+	    *1215*)		driver=foo2hp;; \
+	    *C500*)             driver=foo2slx;; \
+	    *C301*|*C310*)      driver=foo2hiperc;; \
+	    *C3[1234]00*)       driver=foo2hiperc;; \
+	    *C3530*)	        driver=foo2hiperc;; \
+	    *C5[12568][05]0*)   driver=foo2hiperc;; \
+	    *CLP*|*CLX*|*6110*) driver=foo2qpdl;; \
+	    *6015*|*1355*)	driver=foo2hbpl2;; \
+	    *)                  driver=foo2zjs;; \
+	    esac; \
+	    echo $$driver - $$printer; \
+	    ENGINE=../foomatic/foomatic-db-engine; \
+	    PERL5LIB=$$ENGINE/lib \
+		FOOMATICDB=foomatic-db \
+		$$ENGINE/foomatic-ppdfile \
+		-d $$driver -p $$printer \
+		> PPD/$$printer.ppd; \
+	done
+
+oldppd:
+	# Did you do a "make install"????
+	./getweb ppd
+
+#
+# Manpage generation.  No, I am not interested in "info" files or
+# HTML documentation.
+#
+man: $(MANPAGES) man-icc2ps man-osx-hotplug
+
+$(MANPAGES): macros.man includer-man
+
+man-icc2ps:
+	cd icc2ps; $(MAKE) man
+
+man-osx-hotplug:
+	cd osx-hotplug; $(MAKE) man
+
+.1in.1: 
+	-rm -f $*.1
+	modtime() { $(MODTIME); }; \
+	MODpage=`modtime $*.1in`; \
+	MODver=$(VERSION); \
+	./includer-man -v DEF1=$(OLDGROFF) $*.1in | sed > $*.1 \
+	    -e "s@\$${URLOAK}@$(URLOAK)@" \
+	    -e "s@\$${URLZJS}@$(URLZJS)@" \
+	    -e "s@\$${URLHP}@$(URLHP)@" \
+	    -e "s@\$${URLXQX}@$(URLXQX)@" \
+	    -e "s@\$${URLLAVA}@$(URLLAVA)@" \
+	    -e "s@\$${URLQPDL}@$(URLQPDL)@" \
+	    -e "s@\$${URLSLX}@$(URLSLX)@" \
+	    -e "s@\$${URLHC}@$(URLHC)@" \
+	    -e "s/\$${MODpage}/$$MODpage/" \
+	    -e "s/\$${MODver}/$$MODver/"
+	chmod -w $*.1
+
+install-man: man
+	#
+	# Install manual pages
+	#
+	$(INSTALL) -d -m 755 $(MANDIR)
+	$(INSTALL) -d -m 755 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2zjs.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2zjs-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 zjsdecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2oak.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2oak-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 oakdecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hp.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hp2600-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2xqx.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2xqx-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 xqxdecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2lava.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2lava-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 lavadecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 opldecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2qpdl.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2qpdl-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 qpdldecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2slx.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2slx-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 slxdecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hiperc.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hiperc-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 hipercdecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hbpl2.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2hbpl2-wrapper.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 hbpldecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 gipddecode.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 foo2zjs-pstops.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 arm2hpdl.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 usb_printerid.1 $(MANDIR)/man1/
+	$(INSTALL) -c -m 644 printer-profile.1 $(MANDIR)/man1/
+	cd icc2ps; $(MAKE) install-man
+ifeq ($(UNAME),Darwin)
+	cd osx-hotplug; $(MAKE) install-man
+endif
+
+doc: README INSTALL manual.pdf
+
+install-doc: doc
+	#
+	# Install documentation
+	#
+	$(INSTALL) -d -m 755 $(DOCDIR)
+	$(INSTALL) -c -m 644 manual.pdf $(DOCDIR)
+	$(INSTALL) -c -m 644 COPYING $(DOCDIR)
+	$(INSTALL) -c -m 644 INSTALL $(DOCDIR)
+	$(INSTALL) -c -m 644 INSTALL.osx $(DOCDIR)
+	$(INSTALL) -c -m 644 README $(DOCDIR)
+	$(INSTALL) -c -m 644 ChangeLog $(DOCDIR)
+
+GROFF=/usr/local/test/bin/groff
+GROFF=groff
+manual.pdf: $(MANPAGES) icc2ps/foo2zjs-icc2ps.1 osx-hotplug/osx-hplj-hotplug.1
+	-$(GROFF) -t -man \
+	    `ls $(MANPAGES) \
+		icc2ps/foo2zjs-icc2ps.1 \
+		osx-hotplug/osx-hplj-hotplug.1 \
+		| sort` \
+	    | ps2pdf - $@
+
+README: README.in
+	rm -f $@
+	sed < $@.in > $@ \
+	    -e "s@\$${URLOAK}@$(URLOAK)@" \
+	    -e "s@\$${URLZJS}@$(URLZJS)@"
+	chmod -w $@
+
+INSTALL: INSTALL.in Makefile
+	rm -f $@
+	echo "TOPICS" > $@.tmp
+	echo "------" >> $@.tmp
+	grep ^[A-Z][A-Z] $@.in | sed "s/^/    * /" >> $@.tmp
+	echo >> $@.tmp
+	cat $@.tmp $@.in | sed > $@ \
+	    -e "s@\$${URLOAK}@$(URLOAK)@" \
+	    -e "s@\$${URLZJS}@$(URLZJS)@"
+	rm -f $@.tmp
+	chmod -w $@
+
+#
+#	Check db files against current foomatic to see if any changes
+#	need to be made or reported.
+#
+MYFOODB=../foomatic/foomatic-db/db/source
+checkdb:
+	@for dir in driver printer opt; do \
+	    for file in foomatic-db/$$dir/*.xml ; do \
+		ofile=$(MYFOODB)/$$dir/`basename $$file`; \
+		: echo diff -N -u $$ofile $$file; \
+		if [ ! -f  $$ofile ]; then \
+		    ofile=/dev/null; \
+		fi; \
+		diff -N -u $$ofile $$file; \
+	    done \
+	done
+
+#
+#	Mail my latest foomatic-db entries to Till.
+#
+WHO=rick.richardson@comcast.net
+WHO=till.kamppeter@gmx.net
+maildb:
+	$(MAKE) -s checkdb > patch.db
+	echo "Here is a patch for the foomatic-db foo2zjs/foo2oak entries." | \
+	mutt -a patch.db \
+	    -s "foo2zjs/foo2oak - patch for foomatic database" $(WHO)
+
+#
+# Create tarball
+#
+tar:	
+	HERE=`basename $$PWD`; \
+	/bin/ls $(FILES) | \
+	sed -e "s?^?$$HERE/?" | \
+	(cd ..; tar -c -z -f $$HERE/$$HERE.tar.gz -T-)
+
+tarver:	
+	HERENO=`basename $$PWD`; \
+	HERE=`basename $$PWD-$(VERSION)`; \
+	ln -sf $$HERENO ../$$HERE; \
+	/bin/ls $(FILES) | \
+	sed -e "s?^?$$HERE/?" | \
+	(cd ..; tar -c -z -f $$HERE/$$HERE.tar.gz -T-); \
+	rm -f ../$$HERE
+
+#
+# Populate the web site
+#	make web
+#	make webworld
+#	make webextra
+#
+URLOAK=http://foo2oak.rkkda.com
+URLZJS=http://foo2zjs.rkkda.com
+URLHP=http://foo2hp.rkkda.com
+URLXQX=http://foo2xqx.rkkda.com
+URLLAVA=http://foo2lava.rkkda.com
+URLQPDL=http://foo2qpdl.rkkda.com
+URLSLX=http://foo2slx.rkkda.com
+URLHC=http://foo2hiperc.rkkda.com
+URLHBPL=http://foo2hbpl.rkkda.com
+FTPSITE=~/.ncftp-website
+
+foo2zjs.html foo2oak.html foo2hp.html \
+    foo2xqx.html foo2lava.html foo2qpdl.html \
+    foo2slx.html foo2hiperc.html foo2hbpl.html: thermometer.gif FRC
+	rm -f $@
+	HERE=`basename $$PWD`; \
+	TZ=`date | cut -c 21-24`; \
+	modtime() { $(MODTIME); }; \
+	MODindex=`modtime $@.in`; \
+	MODtarball=`modtime $$HERE.tar.gz`; \
+	PRODUCT=`basename $@ .html`; \
+	./includer-html $@.in | sed > $@ \
+	    -e "s@\$${URLOAK}@$(URLOAK)@g" \
+	    -e "s@\$${URLZJS}@$(URLZJS)@g" \
+	    -e "s@\$${URLHP}@$(URLHP)@g" \
+	    -e "s@\$${URLXQX}@$(URLXQX)@g" \
+	    -e "s@\$${URLLAVA}@$(URLLAVA)@g" \
+	    -e "s@\$${URLQPDL}@$(URLQPDL)@g" \
+	    -e "s@\$${URLSLX}@$(URLSLX)@g" \
+	    -e "s@\$${URLHC}@$(URLHC)@g" \
+	    -e "s@\$${URLHBPL}@$(URLHBPL)@g" \
+	    -e "s@\$${PRODUCT}@$$PRODUCT@g" \
+	    -e "s/\$${MODindex}/$$MODindex $$TZ/" \
+	    -e "s/\$${MODtarball}/$$MODtarball $$TZ/"
+	chmod -w $@
+
+web: test tar manual.pdf webindex
+	ncftpput -m -f $(FTPSITE) foo2zjs \
+	    ChangeLog INSTALL manual.pdf foo2zjs.tar.gz;
+
+webt: tar manual.pdf webindex
+	ncftpput -m -f $(FTPSITE) foo2zjs \
+	    ChangeLog INSTALL manual.pdf foo2zjs.tar.gz;
+
+webworld: web webpics
+
+webindex: INSTALL zjsindex oakindex hpindex xqxindex lavaindex \
+	qpdlindex oakindex slxindex hcindex
+
+webpics: redhat suse ubuntu mandriva fedora
+
+webphotos:
+	cd printer-photos; $(MAKE)
+
+zjsindex: foo2zjs.html archzjs.gif thermometer.gif webphotos
+	ln -sf foo2zjs.html index.html
+	ncftpput -m -f $(FTPSITE) foo2zjs \
+	    index.html style.css archzjs.gif thermometer.gif \
+	    images/flags.png INSTALL INSTALL.osx images/zjsfavicon.png \
+	    tablesort.js printer-photos/printers.jpg;
+
+oakindex: foo2oak.html archoak.gif thermometer.gif webphotos
+	ln -sf foo2oak.html index.html
+	ncftpput -m -f $(FTPSITE) foo2oak \
+	    index.html style.css archoak.gif thermometer.gif \
+	    images/flags.png INSTALL \
+	    printer-photos/printers.jpg;
+
+hpindex: foo2hp.html archhp.gif thermometer.gif webphotos
+	ln -sf foo2hp.html index.html
+	ncftpput -m -f $(FTPSITE) foo2hp \
+	    index.html style.css archhp.gif thermometer.gif \
+	    images/flags.png INSTALL images/hpfavicon.png \
+	    printer-photos/printers.jpg;
+
+xqxindex: foo2xqx.html archxqx.gif thermometer.gif webphotos
+	ln -sf foo2xqx.html index.html
+	ncftpput -m -f $(FTPSITE) foo2xqx \
+	    index.html style.css archxqx.gif thermometer.gif \
+	    images/flags.png INSTALL images/xqxfavicon.png \
+	    printer-photos/printers.jpg;
+
+lavaindex: foo2lava.html archlava.gif thermometer.gif webphotos
+	ln -sf foo2lava.html index.html
+	ncftpput -m -f $(FTPSITE) foo2lava \
+	    index.html style.css archlava.gif thermometer.gif \
+	    images/flags.png INSTALL images/lavafavicon.png \
+	    printer-photos/printers.jpg;
+
+qpdlindex: foo2qpdl.html archqpdl.gif thermometer.gif webphotos
+	ln -sf foo2qpdl.html index.html
+	ncftpput -m -f $(FTPSITE) foo2qpdl \
+	    index.html style.css archqpdl.gif thermometer.gif \
+	    images/flags.png INSTALL images/qpdlfavicon.png \
+	    printer-photos/printers.jpg;
+
+slxindex: foo2slx.html archslx.gif thermometer.gif webphotos
+	ln -sf foo2slx.html index.html
+	ncftpput -m -f $(FTPSITE) foo2slx \
+	    index.html style.css archslx.gif thermometer.gif \
+	    images/flags.png INSTALL images/slxfavicon.png \
+	    printer-photos/printers.jpg;
+
+hcindex: foo2hiperc.html archhiperc.gif thermometer.gif webphotos
+	ln -sf foo2hiperc.html index.html
+	ncftpput -m -f $(FTPSITE) foo2hiperc \
+	    index.html style.css archhiperc.gif thermometer.gif \
+	    images/flags.png INSTALL images/hipercfavicon.png \
+	    printer-photos/printers.jpg;
+
+hbplindex: foo2hbpl.html archhbpl.gif thermometer.gif webphotos
+	ln -sf foo2hbpl.html index.html
+	ncftpput -m -f $(FTPSITE) foo2hbpl \
+	    index.html style.css archhbpl.gif thermometer.gif \
+	    images/flags.png INSTALL images/hbplfavicon.png \
+	    printer-photos/printers.jpg;
+
+foo2zjs.html: warning.html contribute.html resources.html unsupported.html
+foo2hp.html: warning.html contribute.html resources.html unsupported.html
+foo2xqx.html: warning.html contribute.html resources.html unsupported.html
+foo2lava.html: warning.html contribute.html resources.html unsupported.html
+foo2qpdl.html: warning.html contribute.html resources.html unsupported.html
+foo2slx.html: warning.html contribute.html resources.html unsupported.html
+foo2hiperc.html: warning.html contribute.html resources.html unsupported.html
+foo2oak.html: warning.html contribute.html resources.html unsupported.html
+foo2hbpl.html: warning.html contribute.html resources.html unsupported.html
+
+# RedHat
+redhat: FRC
+	cd redhat; $(MAKE) web FTPSITE=$(FTPSITE)
+
+# Fedora Core 6+
+fedora: FRC
+	cd fedora; $(MAKE) web FTPSITE=$(FTPSITE)
+
+suse: FRC
+	cd suse; $(MAKE) web FTPSITE=$(FTPSITE)
+
+ubuntu: FRC
+	cd ubuntu; $(MAKE) web FTPSITE=$(FTPSITE)
+
+mandriva: FRC
+	cd mandriva; $(MAKE) web FTPSITE=$(FTPSITE)
+
+#
+#	Extra files from web
+#
+webextra: webicm webfw
+
+webicm: \
+	icm/dl2300.tar.gz \
+	icm/km2430.tar.gz icm/hpclj2600n.tar.gz \
+	icm/hp-cp1025.tar.gz \
+	icm/hpclj2500.tar.gz \
+	icm/hp1215.tar.gz icm/km2530.tar.gz \
+	icm/km-1600.tar.gz \
+	icm/samclp300.tar.gz icm/samclp315.tar.gz \
+	icm/lexc500.tar.gz \
+	icm/okic301.tar.gz \
+	icm/okic310.tar.gz \
+	icm/okic3200.tar.gz \
+	icm/okic3400.tar.gz icm/okic5600.tar.gz
+	ncftpput -m -f $(FTPSITE) foo2zjs/icm icm/dl2300.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2zjs/icm icm/km2430.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2zjs/icm icm/hp-cp1025.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hp/icm icm/hpclj2500.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hp/icm icm/hpclj2600n.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hp/icm icm/hp1215.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2lava/icm icm/km2530.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2lava/icm icm/km-1600.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2qpdl/icm icm/samclp300.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2qpdl/icm icm/samclp315.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2slx/icm icm/lexc500.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hiperc/icm icm/okic301.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hiperc/icm icm/okic310.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hiperc/icm icm/okic3200.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hiperc/icm icm/okic3400.tar.gz;
+	ncftpput -m -f $(FTPSITE) foo2hiperc/icm icm/okic5600.tar.gz;
+
+icm/dl2300.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ CP*.icm DL*.icm
+icm/km2430.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ km2430*.icm
+icm/hp-cp1025.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ hp-cp1025*.icm
+icm/hpclj2500.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ hpclj2500*.icm
+icm/hpclj2600n.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ hpclj2600*.icm
+icm/hp1215.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ hp1215*.icm
+icm/km2530.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ km2530*.icm
+icm/km-1600.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ km-1600*.icm
+icm/samclp300.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ samclp300*.icm
+icm/samclp315.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ samclp315*.icm
+icm/lexc500.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ lexR*.icm
+icm/okic301.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ OKC301*.icm
+icm/okic310.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ OKC310*.icm
+icm/okic3200.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ OK32*.icm
+icm/okic3400.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ C3400*.icm
+icm/okic5600.tar.gz: FRC
+	cd icm; tar -c -z -f ../$@ OK56*.icm
+
+webfw:	firmware/sihp1000.tar.gz \
+	firmware/sihp1005.tar.gz \
+	firmware/sihp1018.tar.gz \
+	firmware/sihp1020.tar.gz \
+	firmware/sihpP1005.tar.gz \
+	firmware/sihpP1006.tar.gz \
+	firmware/sihpP1505.tar.gz \
+	$(NULL)
+	ncftpput -m -f $(FTPSITE) foo2zjs/firmware firmware/*.tar.gz;
+
+firmware/sihp1000.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihp1000.img
+firmware/sihp1005.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihp1005.img
+firmware/sihp1018.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihp1018.img
+firmware/sihp1020.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihp1020.img
+firmware/sihpP1005.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihpP1005.img
+firmware/sihpP1006.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihpP1006.img
+firmware/sihpP1505.tar.gz: FRC
+	cd firmware; tar -c -z -f ../$@ sihpP1505.img
+
+FRC:
+
+#
+# Misc
+#
+misc: pksm2bitcmyk phorum-logo.gif
+
+pksm2bitcmyk: pksm2bitcmyk.c
+	$(CC) $(CFLAGS) pksm2bitcmyk.c -lnetpbm -o $@
+
+phorum-logo.gif: archhp.fig
+	fig2dev -L gif -m.25 archhp.fig | giftrans -t "#ffffff" -o $@
+
+w:	all
+	$(ROOT) $(MAKE) install install-hotplug cups
